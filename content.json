{"meta":{"title":"sakura","subtitle":null,"description":"Stay With You","author":"baizhang","url":""},"pages":[{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-02-03T13:26:47.755Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-02-03T13:26:47.711Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-02-03T13:26:47.798Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-02-03T13:26:47.733Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-02-03T13:26:47.818Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-02-03T13:26:47.777Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-02-03T13:26:47.860Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-02-03T13:26:47.882Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-02-02T14:14:16.000Z","updated":"2020-02-11T05:52:37.181Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2020-02-11T05:53:14.034Z","updated":"2020-02-11T05:53:14.034Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-02-03T13:26:47.840Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-02-04T12:35:55.735Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"GPR_CNN-Undergraduate graduation design","slug":"GPR_CNN","date":"2020-02-27T03:49:59.363Z","updated":"2020-02-27T03:58:00.827Z","comments":true,"path":"2020/02/27/GPR_CNN/","link":"","permalink":"/2020/02/27/GPR_CNN/","excerpt":"","text":"本程序为本科毕设部分内容，参考其他作者的matlab程序。 输入数据为经过处理的雷达数据，其通道数为1（即非RGB三通道），设定 ntrain 点数，在雷达数据的 imagesc 图中选取裂缝分界面的点，共ntrain 个，即 CNN 所需要的训练数据。 验证集使用二维插值 interp2(train_slice,Xq,Zq) 生成。 输出结果为 [0,1] ，即层界面与非层界面。在CNN训练完成后，输入实测数据时，为防止内存爆炸，将图片切割，一部分一部分输入 关于误差： 关于迁移学习： 一、CNN 结构设置网络参数，Learning Rate = 0.1 , Batch Size = 2 , Iterattion 300 epochs 网络结构： 输入特征数为1，第一层输出神经元 6 ，卷积核大小 5 ， 平均池化 ， ​ 输入神经元 6 ，输出神经元 12 ，卷积核 5 ，子采样池化层 ​ 输出预测结果 二、训练集在输入数据（imagesc 图像）中，选择 60 个裂缝点，标记为1，60 个非裂缝点，标记为0 对标记的点进行扩边，dx = dz = 8 , 即构造成边长为 $(2\\times dx+1)\\times(2\\times dz +1)$ 的图像，image_x_new 设置为 32 使用鼠标点击图中的点，保存每个点的横纵坐标值、该点的 value 值，将保存的数据存入结构体变量中，并将 label 属性标注好 将输入的 imagesc 整张图片扩边，填充的数据为最外层的数值，扩边大小为 dx ， dz ， 将每个点做成一个切片 slice ， 切片大小为 $(2\\times dx+1)\\times(2\\times dz +1)$ ，切片的中心数值为原始 imagesc 中的点及其一周 $(2\\times dx)\\times(2\\times dz )$ 的点 ，对其进行二维插值，使得插值后大小为32 x 32 ，即 image_slice_new , 以此作为测试集 (test) 将每个提取的坐标点的位置前后 dx dz 个点组成一个训练数据 slice ，插值后得到 train_slice_new ,32 x 32 开始将每个点构成的 slice 扔入网络中训练。 向训练好的网络扔数据时，由于待分类的数据集（test）过大，很容易导致内存爆炸，因此一般将 test 数据分成100 份，一份一份输入。 在输出的对应 label 的概率，选择概率大的那一个作为预测标签，将输出结果重新拼接 三、matlab代码clear all,close all addpath ./CNN addpath ./util addpath ./data/ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Inputs % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ntrain=100; % The number of training set ntrain1=100; % wdx=8; wdz=8; image_x=wdx*2+1; % Original Image Patch Size X image_z=wdz*2+1; % Original Image Patch Size Z % Intepolate image to make sure size before pooling is even image_x_new=32; % Intepolated Image Patch Size X image_z_new=32; % Intepolated Image Patch Size Z opts.alpha = 1; % Learning Rate opts.batchsize = 2; % Minibatch Size opts.numepochs = 30; % Iteration Number %%%% CNN structure %%%%%%% cnn.layers = { struct(&#39;type&#39;, &#39;i&#39;) %input layer struct(&#39;type&#39;, &#39;c&#39;, &#39;outputmaps&#39;, 6, &#39;kernelsize&#39;, 5) %convolution layer struct(&#39;type&#39;, &#39;s&#39;, &#39;scale&#39;, 2) %sub sampling layer struct(&#39;type&#39;, &#39;c&#39;, &#39;outputmaps&#39;, 12, &#39;kernelsize&#39;, 5) %convolution layer struct(&#39;type&#39;, &#39;s&#39;, &#39;scale&#39;, 2) %sub sampling layer }; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Step 1 Prepare test and training set % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% load real.mat image_input=data; figure(2) imagesc(image_input); colorbar colormap(jet) a = questdlg(&#39;是否导入已有坐标？&#39;,&#39;问题提示&#39;,&#39;Yes&#39;,&#39;No&#39;,&#39;Yes&#39;); % %%%%%%%%%%% Load Prepared training set%%%%%%%%%%%%% % Pick Train Examples % Pick Crack points if a == &quot;Yes&quot; %Crack Points [file_name,path_name] = uigetfile({&#39;*.mat&#39;;&#39;*.dat&#39;;&#39;*.txt&#39;},&#39;Crack Points&#39;); file_path = [path_name file_name] ; data = cell2mat(struct2cell(load(file_path))) ; [ntrain,col]= size(data); train.label(1:ntrain)=1; train.label(2,1:ntrain)=0; train.trainx(1:ntrain) = data(:,1)&#39;; train.trainz(1:ntrain) = data(:,2)&#39;; hold on scatter(data(:,1),data(:,2),18,&#39;or&#39;,&#39;filled&#39;) clear data %Non-Crack Points [file_name,path_name] = uigetfile({&#39;*.mat&#39;;&#39;*.dat&#39;;&#39;*.txt&#39;},&#39;Non-Crack Points&#39;); file_path = [path_name file_name] ; data = cell2mat(struct2cell(load(file_path))) ; % [ntrain,col]= size(data); train.label(ntrain+1:2*ntrain)=0; train.label(2,ntrain+1:2*ntrain)=1; train.trainx(ntrain+1:2*ntrain) = data(:,1)&#39;; train.trainz(ntrain+1:2*ntrain) = data(:,2)&#39;; hold on scatter(data(:,1),data(:,2),18,&#39;ok&#39;,&#39;filled&#39;) % clear data else title(&#39;Pick Crack Points&#39;,&#39;fontsize&#39;,22); train.label(1:ntrain)=1; train.label(2,1:ntrain)=0; for i = 1:ntrain [train.trainx(i),train.trainz(i)]=ginput(1); hold on scatter(train.trainx(i),train.trainz(i),18,&#39;or&#39;,&#39;filled&#39;) title([&#39;Pick Crack Points&#39;,num2str(i),&#39;/&#39;,num2str(ntrain)],&#39;fontsize&#39;,22); end %save label 0 ax1=[train.trainx(1:ntrain)&#39;, train.trainz(1:ntrain)&#39;]; [filename,pathname] = uiputfile({&#39;*.mat&#39;}, &#39;保存坐标&#39;); str=[pathname filename]; save(str,&#39;ax1&#39;) aa = msgbox(&#39;文件已保存&#39;,&#39;OK&#39;,&#39;help&#39;); pause(1) delete(aa) %save label 1 % pause(1) % figure(2) hold on % imagesc(image_input); % caxis ([0 0.8]) % colormap(jet) % Pick No-crack points title(&#39;Pick Non-Crack Points&#39;,&#39;fontsize&#39;,22); train.label(ntrain+1:2*ntrain)=0; train.label(2,ntrain+1:2*ntrain)=1; hold on for i = ntrain+1:2*ntrain [train.trainx(i),train.trainz(i)]=ginput(1); hold on scatter(train.trainx(i),train.trainz(i),18,&#39;ok&#39;,&#39;filled&#39;) title([&#39;Pick Non-Crack Points&#39;,num2str(i-ntrain),&#39;/&#39;,num2str(ntrain)],&#39;fontsize&#39;,22); end % [train.trainx(ntrain+1:2*ntrain),train.trainz(ntrain+1:2*ntrain)]=ginput(ntrain); ax2=[train.trainx(ntrain+1:2*ntrain)&#39;,train.trainz(ntrain+1:2*ntrain)&#39;]; [filename,pathname] = uiputfile({&#39;*.mat&#39;}, &#39;保存坐标&#39;); str=[pathname filename]; save(str,&#39;ax2&#39;) aa = msgbox(&#39;文件已保存&#39;,&#39;OK&#39;,&#39;help&#39;); pause(1) delete(aa) end pause(1) %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Step 2 Convert Image into Image patches % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% [nz,nx]=size(image_input); image_pad=padimage(image_input,wdz,wdx); %%% Obtain image batches from full image image_slice=zeros(image_z,image_x,nz*nx); image_slice_new=zeros(image_z_new,image_x_new,nz*nx); [Xq,Zq]=meshgrid(1:(image_x-1)/(image_x_new-1):image_x,1:(image_z-1)/(image_z_new-1):image_z); ii=1; for ix=1:nx for iz=1:nz image_slice(1:image_z,1:image_x,ii)=image_pad(iz:iz+image_z-1,ix:ix+image_x-1); image_slice_new(:,:,ii)=interp2(image_slice(:,:,ii),Xq,Zq); ii=ii+1; end end %%% Obtain image batches from train set train_slice=zeros(image_z,image_x,2*ntrain); train_slice_new=zeros(image_z_new,image_x_new,2*ntrain); [Xq,Zq]=meshgrid(1:(image_x-1)/(image_x_new-1):image_x,1:(image_z-1)/(image_z_new-1):image_z); for in=1:2*ntrain train_slice(1:image_z,1:image_x,in)=... image_pad(train.trainz(in):train.trainz(in)+image_z-1,train.trainx(in):train.trainx(in)+image_x-1); train_slice_new(:,:,in)=interp2(train_slice(:,:,in),Xq,Zq); end clear image_slice train_slice %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Step 3 Train CNN structure % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%% Input Training and Test set train_x =train_slice_new; % Training set train_y =train.label; % Training label test_x =image_slice_new; % Test set rand(&#39;state&#39;,0) cnn = cnnsetup(cnn, train_x, train_y); cnn = cnntrain(cnn, train_x, train_y, opts); %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Step 4 Input full image for Classification % % (Seperate The Image into 100 parts In case of out of memory) % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %% [a,b,c] = size(image_input) k1 = round(b/10) -1 for ii = 1:k1 disp([&#39;part &#39;,num2str(ii)]) uu = cnnff(cnn,test_x(:,:,a*10*(ii-1)+1 :a*10*ii)); [vv,ll]=max(uu.o); ui=reshape(-ll+2,a,10); un(:,10*(ii-1)+1:10*ii)=ui(:,1:10); end disp([&#39;final part&#39;]) uu = cnnff(cnn,test_x(:,:,a*10*k1+1:b*a)); [vv,ll2]=max(uu.o); ui2=reshape(-ll2+2,a,b-k1*10); un(:,10*k1+1:b)=ui2(:,1:b-k1*10); %% %%%%%%%% Image the result %%%%%%%%%%%% figure(1) subplot(1,2,1) imagesc(image_input) hold on scatter( train.trainx(ntrain+1:2*ntrain), train.trainz(ntrain+1:2*ntrain),18,&#39;ok&#39;,&#39;filled&#39;) hold on scatter( train.trainx(1:ntrain), train.trainz(1:ntrain),18,&#39;or&#39;,&#39;filled&#39;) title({[&#39;Input Image&#39;]},&#39;fontsize&#39;,22,&#39;color&#39;,&#39;black&#39;) set(gca,&#39;fontsize&#39;,22) xlabel(&#39;Pixels&#39;,&#39;fontsize&#39;,22) ylabel(&#39;Pixels&#39;,&#39;fontsize&#39;,22) subplot(1,2,2) imagesc(un) title({[&#39;CNN Labels&#39;]},&#39;fontsize&#39;,22,&#39;color&#39;,&#39;black&#39;) set(gca,&#39;fontsize&#39;,22) xlabel(&#39;Pixels&#39;,&#39;fontsize&#39;,22) ylabel(&#39;Pixels&#39;,&#39;fontsize&#39;,22) set(gcf,&#39;unit&#39;,&#39;centimeters&#39;,&#39;position&#39;,[12 5 30 13]) colormap(parula) %%%%%%%%%Plot the error curve %%%%%%%%%%% figure(2) plot(cnn.rL); title({[&#39;Misfit Curve&#39;]},&#39;fontsize&#39;,22,&#39;color&#39;,&#39;black&#39;) set(gca,&#39;fontsize&#39;,22) xlabel(&#39;Iteration&#39;,&#39;fontsize&#39;,22) ylabel(&#39;Misfit&#39;,&#39;fontsize&#39;,22) % % 添加点数代码： clear all,close all ntrain=20; % The number of training set % 增加标记的点，增加点数时时显示 load real(1).mat image_input=data; figure(1) imagesc(image_input); colorbar a = questdlg(&#39;是否导入已有坐标？&#39;,&#39;问题提示&#39;,&#39;Yes&#39;,&#39;No&#39;,&#39;Yes&#39;); if a == &quot;Yes&quot; %Crack Points [file_name,path_name] = uigetfile({&#39;*.mat&#39;;&#39;*.dat&#39;;&#39;*.txt&#39;},&#39;Crack Points&#39;); file_path = [path_name file_name] ; data = cell2mat(struct2cell(load(file_path))) ; hold on scatter(data(:,1),data(:,2),18,&#39;or&#39;,&#39;filled&#39;) %Non-Crack Points [file_name,path_name] = uigetfile({&#39;*.mat&#39;;&#39;*.dat&#39;;&#39;*.txt&#39;},&#39;Non-Crack Points&#39;); file_path = [path_name file_name] ; data2 = cell2mat(struct2cell(load(file_path))) ; hold on scatter(data2(:,1),data2(:,2),18,&#39;ok&#39;,&#39;filled&#39;) %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % repick points %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% title(&#39;Pick new Crack Points&#39;,&#39;fontsize&#39;,22); hold on for i = ntrain+1:2*ntrain [train.trainx(i),train.trainz(i)]=ginput(1); hold on scatter(train.trainx(i),train.trainz(i),18,&#39;or&#39;,&#39;filled&#39;) title([&#39;Pick Non-Crack Points&#39;,num2str(i-ntrain),&#39;/&#39;,num2str(ntrain)],&#39;fontsize&#39;,22); end ax2=[data;train.trainx(ntrain+1:2*ntrain)&#39;,train.trainz(ntrain+1:2*ntrain)&#39;]; [filename,pathname] = uiputfile({&#39;*.mat&#39;}, &#39;保存坐标&#39;); str=[pathname filename]; save(str,&#39;ax2&#39;) aa = msgbox(&#39;文件已保存&#39;,&#39;OK&#39;,&#39;help&#39;); pause(1) delete(aa) end title(&#39;Pick new NON Crack Points&#39;,&#39;fontsize&#39;,22); train.label(ntrain+1:2*ntrain)=0; train.label(2,ntrain+1:2*ntrain)=1; hold on for i = ntrain+1:2*ntrain [train.trainx(i),train.trainz(i)]=ginput(1); hold on scatter(train.trainx(i),train.trainz(i),18,&#39;ko&#39;,&#39;filled&#39;) title([&#39;Pick Non-Crack Points&#39;,num2str(i-ntrain),&#39;/&#39;,num2str(ntrain)],&#39;fontsize&#39;,22); end % [train.trainx(ntrain+1:2*ntrain),train.trainz(ntrain+1:2*ntrain)]=ginput(ntrain); ax22=[data2;train.trainx(ntrain+1:2*ntrain)&#39;,train.trainz(ntrain+1:2*ntrain)&#39;]; [filename,pathname] = uiputfile({&#39;*.mat&#39;}, &#39;保存坐标&#39;); str=[pathname filename]; save(str,&#39;ax22&#39;) aa = msgbox(&#39;文件已保存&#39;,&#39;OK&#39;,&#39;help&#39;); pause(1) delete(aa)","categories":[],"tags":[],"keywords":[]},{"title":"统计学习方法（笔记）","slug":"统计学习方法","date":"2020-02-04T07:04:03.035Z","updated":"2020-02-23T01:13:32.850Z","comments":true,"path":"2020/02/04/统计学习方法/","link":"","permalink":"/2020/02/04/统计学习方法/","excerpt":"","text":"[TOC] 第一章 统计学习及监督学习理论 1.监督学习 1.特征空间：所有特征向量存在的空间。将实例从输入空间映射到特征空间，模型实际上都是定义在特征空间上的。 2.根据输入输出变量的不同类型，对预测任务给与不同的名称： 输入变量与输出变量均为连续变量——&gt;回归问题； 输出变量为有限个离散变量的预测问题——&gt;分类问题； 输入变量与输出变量均为变量序列的预测问题——&gt;标注问题； 3.假设空间：输入空间到输出空间的映射的集合。 2.强化学习 假设智能系统与环境的互动基于马尔可夫决策过程（Markov decision process），智能系统能观测到的是与环境互动得到的数据序列。 强化学习的本质是学习最优的序贯决策。 序贯决策:是指按时间顺序排列起来，以得到按顺序的各种决策(策略)，是用于随机性或不确定性动态系统最优化的决策方法。 强化学习的马尔可夫决策过程是状态、奖励、动作序列上的随机过程，由五元组&lt;S,A,P,r,γ&gt;组成。 S 有限状态（state）的集合 A是有限动作（action）的集合 P是状态转移概率（transition probability）函数 $$P(s’|s,a)=P(s_{t+1}=s’|s_t=s,a_t=a)$$ r 是奖励函数（reward function）：$$ r(s,a)=E(r_{t+1}|s_t=s,a_t=a)$$ γ是衰减系数（discount factor）：γ∈[0,1] 策略：Π 价值函数（value function）/状态价值函数（state value function）： 动作价值函数（action value function）: 3.正则化$$\\min_{f\\in \\mathcal F} \\frac{1}{N}\\sum _{i=1} ^NL(y_i,f(x_i))+\\lambda J(f)$$ 其中，第1项是经验风险，第2项是正则化项，$$\\lambda \\ge0$$为调整两者之间关系的系数。 在回归问题中，损失函数是平方损失，正则化项可以是参数向量的$$L_2$$范数：$$L(w)=\\frac{1}{N}\\sum _{i=1} ^N(f(x_i;w)-y_i)^2 \\frac{\\lambda}{2}||w||^2$$这里，$||w||^2$表示向量 $w$的$L_2$范数。 从贝叶斯估计的角度来看，正则化项对应着模型的先验概率。 4.泛化误差上界 定理 对二分类问题，当假设空间是有限个函数的集合$$\\mathcal F ={f_1,f_2,\\cdot \\cdot \\cdot ,f_d}$$时，对任意一个函数$$f\\in \\mathcal F$$ ,至少以概率1-δ，0&lt;δ&lt;1，一下不等式成立：$$R(f) \\le \\hat R(f) + \\varepsilon(d,N,\\delta)$$其中，$$\\varepsilon = \\sqrt{\\frac{1}{2N}(log\\,d+log\\,\\frac{1}{\\delta})}$$ 推到过程（关键步骤）：$$\\begin{aligned}P(\\exist f \\in \\mathcal F :R(f) - \\hat R(f))&amp;=P(\\bigcup_{f \\in \\mathcal F} { R(f) - \\hat R(f) \\ge \\varepsilon })\\qquad#各个模型发生概率的和事件，取并集\\&amp;\\le \\sum _{f \\in \\mathcal F}P(R(f) - \\hat R(f)\\ge \\varepsilon)\\qquad \\quad#加法公式P(A\\bigcup B) \\le P(A)+P(B)\\&amp;\\le d\\,exp(-2N\\varepsilon^2)\\qquad\\qquad \\qquad\\quad#Hoeffding不等式 \\end{aligned}$$ 5.监督学习应用$$\\begin{cases}分类问题\\begin{cases}分类器（学习系统、分类系统） \\评价指标\\begin{cases}分类准确率\\精确率：预测正确的正类数/预测的总正类数\\召回率：预测正确的正类数/真正类总数\\F_1值：精确率和召回率的调和平均值 \\end{cases}\\end{cases}\\标注问题\\begin{cases}结构预测问题的简单形式\\常用方法：隐马尔可夫模型、条件随机场 \\end{cases}\\回归问题\\end{cases}$$ 第二章 感知机 感知机对应于输入空间（特征空间）中将实例划分为正负两类的分离超平面，属于判别模型。$$f(x) = sign(w\\, \\cdot \\, x+b )\\其中，\\mathcal X \\sube \\mathbf R^n, x\\in \\mathcal X,\\mathcal Y ={ +1,-1 };\\y\\in \\mathcal Y\\;表示实例的类别$$ $$sign(x)=\\begin{cases}+1,\\quad x\\ge0 \\-1,\\quad x \\le 0 \\end {cases}$$ 感知机的假设空间是定义在特征空间中的所有线性分类模型或线性分类器，即函数集合 $${f|f(x)=w\\cdot x+b}$$ 。 几何解释： 线性方程 $$w \\cdot x +b=0$$ ，对应于特征空间 $$\\mathbf R^n $$ 中的一个超平面S，其中 w 是超平面的法向量，b 是超平面的截距。这个超平面将特征空间划分为两部分。超平面S称为分离超平面（separating hyperplane ）","categories":[{"name":"AI","slug":"AI","permalink":"/categories/AI/"}],"tags":[],"keywords":[{"name":"AI","slug":"AI","permalink":"/categories/AI/"}]},{"title":"地震作业","slug":"地震作业","date":"2020-02-04T07:04:03.033Z","updated":"2020-02-23T01:13:45.391Z","comments":true,"path":"2020/02/04/地震作业/","link":"","permalink":"/2020/02/04/地震作业/","excerpt":"","text":"[toc] 一、设置模型网格大小设置为 $$ 200\\times300 $$ ,均匀划分三层，层速度为2500 m/s , 4000 m/s , 5000 m/s CMP道集： （ Common Middle Point ）共中心点道集 速度分析原理： ​ 由于$$t_0$$未知，均方根速度v 未知，因此采用穷举法，遍历每一个$$t_0$$时刻对应的每一个可能的均方根速度 v ​ 根据假设的$$t_0$$和 v ，将所有CMP道的地震记录振幅求取平均值，当$$t_0$$与均方根速度v 都和实际地层吻合时，振幅达到最大。 ​ 绘制振幅的 v - $$t_0$$ 等值线图，等值线最为密集处即为振幅最大值点，即所求的参数，再依据迪克斯公式，即可反演出相应的层速度，进而可求出地层厚度 import numpy as np # import numpy.matlib import matplotlib.pyplot as plt import math ####### # Three layers model # set parameters X = 100; Y = 30 v1 = 2500; v2 = 4000; v3 = 5000 dx = 20; dz = 20; dt = 0.001 rou = [1.0]*3 t1 = 2*dz*Y/3/v1 ; t2 = 2*dz*Y/3/v2 t0 = np.array([t1, t1 + t2]) v = np.array([v1, np.sqrt((np.power(v1, 2)*t1+np.power(v2, 2)*t2)/(t1+t2))]) print(&#39;True velocity :\\n&#39;,&#39;v1 = &#39;,v1,&#39; m / s\\nv2 = &#39;,v2,&#39; m / s&#39;) # calculate times temp1 = []; temp2 = [] x = np.linspace(dx,X*dx,X) for xx in x: # record times # temp = [[2*np.sqrt(np.power(xx*dx,2)/np.power(v[0],2)+np.power(t0[0],2))],[2*np.sqrt(np.power(xx*dx,2)/np.power(v[1],2)+np.power(t0[1],2))]] temp1.append(round(np.sqrt(np.power(xx,2)/np.power(v[0],2)+np.power(t0[0],2)),3)) temp2.append(round(np.sqrt(np.power(xx,2)/np.power(v[1],2)+np.power(t0[1],2)),3)) T = np.array([temp1, temp2]).T max_t = max([max(temp1),max(temp2)]) +0.2 # print(&#39;The total time is :&#39;,max_t,&#39; s&#39;) # print(T.shape) # calculate parameters Z1 = rou[0]*v1; Z2 = rou[1]*v2; Z3 = rou[2]*v3 R = (Z2 - Z1)/(Z2 + Z1) Tou = 4*rou[0]*rou[1]*v1*v2*(Z3-Z2)/(np.power(Z1+Z2,2)*(Z3+Z2)) # plot cmp Z = np.linspace(0, max_t, max_t*(1/dt) + 1) # 此时，Z[1]即为0.001 cmp_1 = np.zeros((int(max_t*(1/dt))+1,X)) for xx in range(X): cmp_1[int(T[xx,0]*int(1/dt))][xx] = R*35 cmp_1[int(T[xx,1]*int(1/dt))][xx] = Tou*35 plt.plot(cmp_1[:,xx]+dx*(xx+1),Z,&#39;k&#39;) ax = plt.gca() ax.invert_yaxis() ax.spines[&#39;bottom&#39;].set_color(&#39;none&#39;); ax.spines[&#39;right&#39;].set_color(&#39;none&#39;) ax.xaxis.set_ticks_position(&#39;top&#39;) ax.set_title(&#39;offset-t cmp&#39;) ax.tick_params(direction=&#39;in&#39;) plt.show() # ricker subwave def ricker(t,fm): a = 1-2*np.square(math.pi*fm*t)*np.exp(-np.square(math.pi*fm*t)) return a # convolve x_ = np.linspace(-0.01, 0.01, 21) y_ = ricker(x_,30)*100 # lenth = int(max_t*(1/dt))+21 cmp_1 = cmp_1/35 # cmp_2 = np.zeros((lenth,X)) cmp_2 = cmp_1 for xx in range(X) : # cmp_2[:, xx] = np.convolve(cmp_1[:,xx], y_, mode=&#39;full&#39;) cmp_2[:, xx] = np.convolve(cmp_1[:,xx], y_, mode=&#39;same&#39;) # plt.plot(cmp_2[:,xx]+dx*(xx+1),range(lenth),&#39;k&#39;) plt.plot(cmp_2[:,xx]+dx*(xx+1),Z,&#39;k&#39;) ax1 = plt.gca() ax1.invert_yaxis() ax1.spines[&#39;bottom&#39;].set_color(&#39;none&#39;); ax1.spines[&#39;right&#39;].set_color(&#39;none&#39;) ax1.xaxis.set_ticks_position(&#39;top&#39;) ax1.set_title(&#39;cmp convolve ricker&#39;) ax1.tick_params(direction=&#39;in&#39;) plt.show() # add noise for xx in range(X) : cmp_2[:, xx] = cmp_2[:, xx] + np.random.randn(int(max_t*(1/dt)) + 1) plt.plot(cmp_2[:,xx]+dx*(xx+1),Z,&#39;k&#39;) ax2 = plt.gca() ax2.invert_yaxis() ax2.spines[&#39;bottom&#39;].set_color(&#39;none&#39;); ax1.spines[&#39;right&#39;].set_color(&#39;none&#39;) ax2.xaxis.set_ticks_position(&#39;top&#39;) ax2.set_title(&#39;cmp add noise&#39;) ax2.tick_params(direction=&#39;in&#39;) plt.show() plt.show() # velocity spectrum M = 40 start_1 = round(T[X-1, 0] - M*dt, 3); end_1 = T[X-1, 0] + M*dt start_2 = round(T[X-1, 1] - M*dt, 3); end_2 = T[X-1, 1] + M*dt # t_min ~ t_max tn_1 = np.linspace(start_1,end_1,2*M+1) - t0[0] tn_2 = np.linspace(start_2,end_2,2*M+1) - t0[1] # print(&#39;dfsadgadsg&#39;,start_1,end_1,start_1-end_1,start_1+end_1) v_s1 = dx*X/np.sqrt(2*t0[0]*tn_1 + np.square(tn_1)) v_s2 = dx*X/np.sqrt(2*t0[1]*tn_2 + np.square(tn_2)) # print(tn_1) # print(end_1,start_1,int((end_1-start_1)/dt)) # 这样计算时，由于小数浮点型十进制转二进制舍入误差造成0.16-0.015！= 0.145，计算结果为0.145000000000002 A_1 = np.zeros((2*M+1, 1)) A_2 = np.zeros((2*M+1, 1)) for zz in range(2*M + 1): for xx in range(X): A_1[zz] = A_1[zz] + cmp_2[int(T[xx, 0]/dt) - M + zz, xx] A_2[zz] = A_2[zz] + cmp_2[int(T[xx, 1]/dt) - M + zz, xx] A_1[zz] = A_1[zz]/X A_2[zz] = A_2[zz]/X # a=float(max(A_2)) # b=float(min(A_2)) # print(max(A_2),min(A_2),round(a,1),round(b,1)) # print(A_2) plt.plot(np.array(v_s1),np.array(A_1) + t0[1]/dt -60,&#39;k&#39;) plt.plot(np.array(v_s2),np.array(A_2) + t0[0]/dt,&#39;k&#39;) ax4 = plt.gca() # ax4.invert_yaxis() ax4.spines[&#39;bottom&#39;].set_color(&#39;none&#39;); ax4.spines[&#39;right&#39;].set_color(&#39;none&#39;) ax4.xaxis.set_ticks_position(&#39;top&#39;) ax4.yaxis.set_ticks_position(&#39;none&#39;) ax4.set_title(&#39;velocity spectrum&#39;) ax4.tick_params(direction=&#39;in&#39;) ax4.tick_params(&#39;y&#39;, labelleft=False) ax4.grid(True) plt.show() # contour temp_c = 0 V_c = np.linspace(2000,4500,51) cmp_3 = np.zeros((int(max_t*(1/dt) )+ 1,51)) for tt in Z: # 小窗口时间 for vv in V_c: for xx in x: TT = round(np.sqrt(np.square(xx)/np.square(vv)+np.square(tt)),3) if TT &gt; max_t : continue else: temp_c = temp_c + round(cmp_2[int(TT/dt), int(xx/dx)-1]) # print((vv-1500/5)) cmp_3[int(tt/dt),int((vv-2000)/50)] = temp_c/X temp_c = 0 # print(tt) v_c,z = np.meshgrid(V_c,Z) C = plt.contour(v_c,z,cmp_3,[6,8,9,11,15],colors = &#39;black&#39;) # plt.clabel(C,inline = True) ax5 = plt.gca() ax5.grid(True) ax5.invert_yaxis() ax5.spines[&#39;bottom&#39;].set_color(&#39;none&#39;); ax5.spines[&#39;right&#39;].set_color(&#39;none&#39;) ax5.xaxis.set_ticks_position(&#39;top&#39;) ax5.yaxis.set_ticks_position(&#39;none&#39;) ax5.set_title(&#39;velocity spectrum&#39;) ax5.set_xlabel(&#39;V (m/s)&#39;) ax5.set_ylabel(&#39;T (s)&#39;) plt.show() # # layer velocity # 理论均方根速度V2 = 3162.2776601683795 m/s import numpy as np v_rms = [2500, 3152] t_rms = [0.16, 0.2595] print(type(v_rms[0])) v_inverse = [] v_inverse.append(v_rms[0]) v_inverse.append(np.sqrt((np.square(v_rms[1])*t_rms[1] - np.square(v_rms[0])*t_rms[0])/(t_rms[1]-t_rms[0]))) print(&#39;The velocity of first layer is &#39;, v_inverse[0], &#39;m/s&#39; ,&#39;\\nThe velocity of second layer is &#39;,v_inverse[1],&#39; m/s&#39;) 更新内容：1.输出图片 ​ 2.计算层速度","categories":[{"name":"Geophysics","slug":"Geophysics","permalink":"/categories/Geophysics/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}],"keywords":[{"name":"Geophysics","slug":"Geophysics","permalink":"/categories/Geophysics/"}]},{"title":"大创软件设计","slug":"大创软件设计","date":"2020-02-04T07:04:03.021Z","updated":"2020-02-04T13:03:45.045Z","comments":true,"path":"2020/02/04/大创软件设计/","link":"","permalink":"/2020/02/04/大创软件设计/","excerpt":"","text":"[toc] 一、设计背景二、各模块设计(一)、登录模块在命令行输入guide命令，新建fig文件；使用静态文本（Static Text）作为文本框，使用可编辑文本（Edit Text）获取输入的用户信息，使用放置按钮（Push Button）进行登录。 1.用户名输入框提醒，点击消失 输入框内，提醒内容可以很方便的在输入框（可编辑文本）的String属性中提前加入，并更改ForegroundColor属性以调整颜色 在ButtonDownFcn函数下，输入以下代码内容： set(hObject,&#39;String&#39;,&#39;&#39;,&#39;Enable&#39;,&#39;on&#39;); set(hObject,&#39;ForegroundColor&#39;,[0,0,0]); uicontrol(hObject); 第一行代码为清空输入框内容； 第二行代码为把字体颜色调成默认的黑色； 第三行代码为继续控制GUI界面。如果少了这一句，当点击输入框时，前两行代码正常执行，提示内容消失，但当键盘开始输入时，输入内容会输入在MATLAB的命令行窗口。 Callback 与 ButtonDownFcn 的区别 两函数的调用要涉及的另一个用于使能或禁用控件的属性 Enable，此属性包含三个可选值：{on}、off、inactive，on 为默认属性。当 Enable 为 on 时，在 Push Button上单击左键时，调用 Callback 函数，单击右键时，调用 ButtonDownFcn 函数。在 Push Button 周围5像素范围内单击左键或右键，不论 Enable 取何值，都将调用 ButtonDownFcn 函数。可见，当 Enable 为 on 时，可以实现单击左键、右键有不同的响应。 获取edit文本中的字符串，代码如下： global a %其中，global定义的变量必须每个变量一个global，否则无法识别 a=get(handles.edit,&#39;string&#39;); str2double(a) msgbox(&#39;afjda;g&#39;,&#39;帮助信息&#39;,&#39;help&#39;) errordlg(&#39;&#39;,&#39;&#39;,&#39;&#39;) 2.保护输入密码的显示 方法一： 如果不强调一定要用星号来隐藏所输入的密码字符，则可以直接设置Edit Text控件的属性“FontName”来完成密码隐藏功能。 具体地，双击用作输入密码的Edit Text控件，打开其属性设置面板（Property Inspector ），找到属性“FontName”，默认的字体名为“MS Sans Serif”，将字体改为“Symbol”，即可完成密码隐藏功能。 方法二： 不改变字体，而是通过代码，修改用作输入密码的Edit Text控件的“KeyPressFcn”函数。具体地： global passWord passWord = get( hObject, &#39;UserData&#39; ); switch eventdata.Key case &#39;backspace&#39; passWord = passWord( 1:end-1 ); case &#39;return&#39; % uiresume; return; otherwise passWord = [passWord eventdata.Character]; end set( hObject, &#39;UserData&#39;, passWord ); set( hObject, &#39;String&#39;, char( &#39;*&#39;*sign(passWord) ) ); 其中 passWord 即为输入的密码字符串 , 该方法唯一不足之处在于，输入密码时，光标始终在左边！ 3.修改左上角标题名称 在程序的OpeningFcn函数中加入这么一句命令： set(gcf,&#39;numbertitle&#39;,&#39;off&#39;,&#39;name&#39;,&#39;标题名称&#39;) 4.登录按钮设置function pushbutton1_Callback(hObject, eventdata, handles) % 登录按钮 global cName; global cCode; if( ~strcmp(cName,&#39;12345678910&#39;) || ~strcmp(cCode , &#39;971122&#39;) ) errordlg(&#39;用户名或密码错误&#39;,&#39;错误提醒&#39;,&#39;modal&#39;); set(handles.edit2,&#39;string&#39;,&#39;&#39;); return; else close; GEST; end 其中，GEST为登陆后的程序界面GEST.fig文件,close关闭当前登录界面 5.用户信息数据库使用cell形式存储，建立mat数据库文件，本软件采用上述唯一账号密码，故略去数据库的建立。 6.插入背景图片ha=axes(&#39;units&#39;,&#39;normalized&#39;,&#39;pos&#39;,[0 0 1 1]); uistack(ha,&#39;down&#39;); ii=imread(&#39;background.jpg&#39;); image(ii); colormap gray set(ha,&#39;handlevisibility&#39;,&#39;off&#39;,&#39;visible&#39;,&#39;on&#39;); (二)、主窗体设计包括建立各级子菜单 1)建立按钮中断其他回调，使用waitfor在将数据添加到表之前，等待用户选中复选框。复选框的 Value 属性在未选中时为 0，在选中时为 1。 t = uitable; c = uicontrol(&#39;Style&#39;,&#39;checkbox&#39;,&#39;String&#39;,&#39;Add data&#39;); c.Position = [320 100 80 20]; waitfor(c,&#39;Value&#39;); t.Data = magic(5); 2)建立waitbarh=waitbar(0,&#39;please wait&#39;); for i=1:1000 %computation here% b=num2str(round(i/10)); s=[&#39;please wait:&#39; ,b ,&#39;%&#39;]; waitbar(i/1000,h,s) end delete(h); 3)弹出输入框常见用法answer = inputdlg(prompt,dlgtitle,numlines,defAns);prompt显示内容dlgtitle 标题numlines输入框长度defAns默认输入值answer为输入的数据，以元胞数组的形式储存在里面，而且储存的数据形式都是字符串 4)提问对话框a = questdlg(&#39;中午吃饭了吗？&#39;,&#39;问题提示&#39;,&#39;Yes&#39;,&#39;No&#39;,&#39;Yes&#39;); # 最后一个Yes 表示对话框默认选项，即弹出式，Yes选项会深色显示 button = questdlg(&#39;qstring&#39;,&#39;title&#39;,&#39;str1&#39;,&#39;str2&#39;,&#39;str3&#39;,default) Descriptionbutton = questdlg(&#39;qstring&#39;) displays a modal dialog box presenting the question &#39;qstring&#39;. The dialog has three default buttons, Yes, No, and Cancel. If the user presses one of these three buttons, button is set to the name of the button pressed. If the user presses the close button on the dialog without making a choice, button is set to the empty string. If the user presses the Return key, button is set to &#39;Yes&#39;. &#39;qstring&#39; is a cell array or a string that automatically wraps to fit within the dialog box. 一行输入框： clc;clear;close all; answer=inputdlg(&#39;a=？&#39;,&#39;输入&#39;,[1 30],{&#39;5&#39;}); 多行输入框： clc;clear;close all; answer=inputdlg({&#39;姓名&#39;,&#39;阶数&#39;},&#39;请输入&#39;,[1 30;1 30],{&#39;ABC&#39;,&#39;30&#39;}); peaks(str2num(answer{2})); msgbox([answer{1},&#39;您好您当前正在执行的是&#39;,&#39;peaks(&#39;,answer{2},&#39;)&#39;]); (三)、数据导入及存储模块1.数据导入输入格式应包括txt、mat、dat等格式，由于对应于一个函数，打开的文件无法始终保存在工作空间之中，因此传递一个global变量记录文件路径，供其他模块调用。 function Untitled_6_Callback(hObject, eventdata, handles) % 打开文件 [file_name,path_name] = uigetfile({&#39;*.mat&#39;;&#39;*.dat&#39;;&#39;*.txt&#39;},&#39;打开文件&#39;); %在电脑中查找文件，弹出浏览窗口，‘打开文件’为左上角标题，文件名和路径存储在name和path变量之中，但此时未导入变量 global file_path file_path = [path_name file_name] fid = fopen(file_path) if (fid &gt; 0) % h=dialog(&#39;name&#39;,&#39;文件&#39;,&#39;position&#39;,[200 200 200 70]); % uicontrol(&#39;parent&#39;,h,&#39;style&#39;,&#39;text&#39;,&#39;string&#39;,&#39;文件打开成功&#39;,&#39;position&#39;,[50 40 120 20],&#39;fontsize&#39;,12); % uicontrol(&#39;parent&#39;,h,&#39;style&#39;,&#39;pushbutton&#39;,&#39;position&#39;,[80 10 50 20],&#39;string&#39;,&#39;确定&#39;,&#39;callback&#39;,&#39;delete(gcbf)&#39;); msgbox(&#39;文件打开成功&#39;,&#39;文件&#39;,&#39;help&#39;) else h=errordlg(&#39;文件打开失败&#39;,&#39;error&#39;); end li = 0; while ~feof(fid) tline = fgetl(fid); li = li+1; end global line_num line_num = li % hObject handle to Untitled_6 (see GCBO) % eventdata reserved - to be defined in a future version of MATLAB % handles structure with handles and user data (see GUIDATA) 当使用load 命令时，若加路径名称，需要使用括号，如 data = load(‘D:\\a.mat’) 此时data 为一个 struct 结构体，若想转换为矩阵，则需要先转换为 cell ,再由cell转换为 mat,具体命令如下： data = cell2mat(struct2cell(load(&#39;a.mat&#39;))); 判断load 的mat 文件中包含的变量个数： [file_name,path_name] = uigetfile({&#39;*.mat&#39;;&#39;*.dat&#39;;&#39;*.txt&#39;},&#39;打开文件&#39;); %在电脑中查找文件，弹出浏览窗口，‘打开文件’为左上角标题，文件名和路径存储在name和path变量之中，但此时未导入变量 global file_path file_path = [path_name file_name] % d = cell2mat(struct2cell(load(file_path))); b=whos(&#39;-file&#39;,file_path) # b 为struct 形式，变量个数为n,b的大小为nx1 c=size(b) sum(c) %open file [file_name,path_name] = uigetfile({&#39;*.mat&#39;;&#39;*.dat&#39;;&#39;*.txt&#39;},&#39;打开文件&#39;); global file_path file_path = [path_name file_name] ; global data if (strcmp(file_name(end-3:end) , &#39;.mat&#39;)) b=whos(&#39;-file&#39;,file_path); c=size(b); if(sum(c) ~= 2) errordlg(&#39;输入数据应只包含一个变量&#39;,&#39;错误&#39;,&#39;modal&#39;); return end end data = cell2mat(struct2cell(load(file_path))) ; imagesc(data(:,:,1)) aa = msgbox(&#39;导入成功&#39;,&#39;OK&#39;,&#39;help&#39;); pause(1) delete(aa) 2.文件存储1）存储当前窗口图片function uipushtool3_ClickedCallback(hObject, eventdata, handles) % 保存图片 [filename,pathname] = uiputfile({&#39;*.jpg&#39;;&#39;*.bmp&#39;;&#39;*.gif&#39;;&#39;*.png&#39;;&#39;*.tif&#39;}, &#39;Write Pic&#39;); str=[pathname filename]; if str~=0 saveas(gcf,str); end % --- 文件的保存 --- [file,path] = uiputfile(&#39;*.mat&#39;,&#39;Save Mask As&#39;); save(strcat(path,file),&#39;mask&#39;); % --- 创建一个进度条 --- wait = waitbar(0.1,&#39;Loading data from disk...&#39;); waitbar(0.2,wait); waitbar(1.0,wait); close(wait); % --- 在名为display的axes显示图像，然后关闭 --- img = imagesc(data, &#39;Parent&#39;,handles.display); close img; 2)保存数据save(&#39;data.mat&#39;,&#39;a&#39;,&#39;b&#39;)的方式，data.mat是生成的mat文件名，a和b是存入的变量 保存对当前文件的更改： global file_path save(file_path,&#39;data&#39;) msgbox(&#39;文件已保存&#39;,&#39;OK&#39;,&#39;help&#39;) 文件另存为： [filename,pathname] = uiputfile({&#39;*.mat&#39;;&#39;*.dat&#39;;&#39;*.txt&#39;}, &#39;另存为&#39;); str=[pathname filename] save(str,&#39;data&#39;) msgbox(&#39;文件已保存&#39;,&#39;OK&#39;,&#39;help&#39;) (四)、正演模块1.速度模型1）marmousi模型提供计算好的结果 2.参数设置3.波场快照暂停/继续 设置在开始按钮回调函数中，定义一个global变量val用作开关，其值为0/1；将输出时刻k同样设置为global变量，以传入暂停/继续按钮回调函数中;判断val的值是否为1，否时使用break退出循环。同时，imagesc命令后需要加pause命令才会有动态效果，否则只会生成最后一张图。 由于点击暂停/继续按钮后，不再激活开始按钮的回调函数，故将开始的回调函数复制进该按钮。 下面为暂停/继续的代码： function pushbutton8_Callback(hObject, eventdata, handles) global val if(val == 0) %实现开关作用 val=1 else val = 0 return; %此处必须return，否则进入while中的循环，无法退出 end global k %使得“继续”命令后能使图像连续，传入参数 global u global mdd [a,b]=meshgrid(0:24:24*383,0:24:24*121); while(k&lt;=60) if (val) imagesc(0:24:24*383,0:24:24*121,u(:,:,k),[-1,1]) title([&#39;波场快照 第 &#39;,num2str(k*0.02),&#39; s&#39;]) hold on contour(a,b,mdd,&#39;k&#39;) hold on plot(24*(384)/2,20,&#39;pr&#39;,&#39;MarkerSize&#39;,13) text(24*(384)/2+35,80,&#39;震源&#39;,&#39;FontSize&#39;,11) h2=colorbar; set(get(h2,&#39;Title&#39;),&#39;string&#39;,&#39;u &#39;); colormap(jet) k=k+1; end pause(0.1) end 清空当前窗口图像使用命令cla(gca); 翻页、跳转页面操作由于自动放映时，暂停后对k 多加了一个1，采用新增变量page判断是否经过暂停k多加1的过程。 代码如下： function pushbutton5_Callback(hObject, eventdata, handles) %上一页 global k global u global a global b global mdd global val global page if(val == 0 &amp;&amp; page == 0) %判断之前操作是否为暂停 k=k-1; page = 1; end if (k==1) msgbox(&#39;当前为第一页&#39;,&#39;错误&#39;,&#39;error&#39;); else k=k-1; imagesc(0:24:24*383,0:24:24*121,u(:,:,k),[-1,1]) title([&#39;波场快照 第 &#39;,num2str(k*0.02),&#39; s&#39;]) hold on contour(a,b,mdd,&#39;k&#39;) hold on plot(24*(384)/2,20,&#39;pr&#39;,&#39;MarkerSize&#39;,13) text(24*(384)/2+35,80,&#39;震源&#39;,&#39;FontSize&#39;,11) h2=colorbar; set(get(h2,&#39;Title&#39;),&#39;string&#39;,&#39;u &#39;); colormap(jet) end 4.合成地震记录单炮激发，某个深度下，同一水平层所有时间位移响应构成的二维矩阵 5.模型图6.噪声answer=inputdlg(&#39;噪声幅值&#39;,&#39;input rand noise&#39;,[1 30],{&#39;1&#39;}); a = str2num(answer{1}); global data [nx,ny,nz]=size(data); noise = data + a*rand(nx,ny,nz) ; [filename,pathname] = uiputfile({&#39;*.mat&#39;;&#39;*.dat&#39;;&#39;*.txt&#39;}, &#39;另存为&#39;); str=[pathname filename] save(str,&#39;noise&#39;) msgbox(&#39;文件已保存&#39;,&#39;OK&#39;,&#39;help&#39;) 7.SVI处理新建一个gui 界面，具体实现见SVI模块 svi原理： 地震炮集记录中，特别是陆地地震数据，远偏移距数据由于信号能量弱，噪声干扰大，往往很难得到有效的初至时地震波记录。 ​ 采用超分辨率地震干涉技术对地震炮集记录进行增强处理，其基本原理是对每一个检波器记录信号利用互相关和卷积方法进行处理。通过数值模拟和实测数据测试，形成一套完整的超分辨率地震干涉处理方法 (五)、SVI模块1.窗口化从地震记录图中使用鼠标截取窗口进行过滤处理。 a=peaks(100); %a是个二维矩阵 imagesc(a); %利用二维矩阵a画图，会生成一个figure窗口 h=imrect(gca) %运行完这句后，可以在图中框出需要的区域 pos = getPosition(h); %待区域决定后，运行这句就会返回区域的位置和大小 %pos返回的是四个值 % [xmin ymin width height]. col=round(pos(1)):round(pos(1)+pos(3)); %根据pos计算lie下标 row=round(pos(2)):round(pos(2)+pos(4)); %根据pos计算hang下标 %由于pos返回有小数，用round取整 b=a(row,col); %根据row，col，从a中提取矩阵b figure imagesc(b) 使用鼠标点击提取点坐标 function Untitled_7_Callback(hObject, eventdata, handles) % 选择窗口 figure global data imagesc(data(:,:,1)) x1=[];y1=[]; for i =1:4 [a,b] = ginput(1) hold on x1=[x1;a]; y1=[y1;b]; plot(a,b,&#39;ro&#39;) end plot(x1,y1,&#39;r&#39;) x2=[];y2=[]; for i =1:4 [c,d] = ginput(1) hold on x2=[x2;c]; y2=[y2;d]; plot(c,d,&#39;ro&#39;) end plot(x2,y2,&#39;r&#39;) ax =[x1 y1 x2 y2]; [filename,pathname] = uiputfile({&#39;*.mat&#39;}, &#39;保存坐标&#39;); str=[pathname filename]; save(str,&#39;ax&#39;) msgbox(&#39;文件已保存&#39;,&#39;OK&#39;,&#39;help&#39;) 依据鼠标获取的坐标，使用带通滤波函数，将选取部分保留，其余部分归零，得到窗口。 [nt,ng,ns]=size(data); Normalize=1; % 0 = no normalization, 1 = CSG normalization, 2 = Trace normalization bp=0; % 0 = no bandpass, 1 = do bandpass lcut=5; lpass=10; hpass=80; hcut=110; ntr=3; % number of traces to mute at right and left sides of the shot mut_r=1; % Mute around refracted waves 消减附件反射波 tap_size=20; % Size of taper window around refracted waves, in samples uper=(1:ng)&#39;; lower=uper; uper(:,2)=interp1(uperT(:,1),uperT(:,2),uper(:,1)); lower(:,2)=interp1(lowerT(:,1),lowerT(:,2),lower(:,1)); for is=1:ns %每个炮点位置 pos = is*dx-4; cg=data(:,:,is); if bp==1 cg=BandPass(cg,lcut,lpass,hpass,hcut,dt); end if ntr&gt;0 %震源两侧削弱道数 st=pos-ntr; %is为列号，即当前震源位置所在列 ed=pos+ntr; if st&lt;1;st=1;end if ed&gt;ng;ed=ng;end cg(:,st:ed)=0; end if Normalize==1 &amp;&amp; max(abs(cg(:)))~=0 %地震记录数据归一化 cg=cg/max(abs(cg(:))); elseif Normalize==2 for j=1:ng if max(abs(cg(:,j)))~=0 cg(:,j)=cg(:,j)/max(abs(cg(:,j))); end end end if mut_r==1 %消减反射波 uper_1(pos:ng,1)=round(uper(1:ng-pos+1,2)); % ng-is 总列数-图号（震源位置） uper_1(1:pos-1,1)=round(flipud(uper(1:pos-1,2)));% 翻转对称性质，地震道关于震源位置对称 lower_1(pos:ng,1)=round(lower(1:ng-pos+1,2)); lower_1(1:pos-1,1)=round(flipud(lower(1:pos-1,2))); for j=1:ng %列号 st=uper_1(j)-tap_size; ed=lower_1(j)+tap_size; if st&gt;0; cg(1:st,j)=0; end if ed&lt;nt; cg(ed:end,j)=0; end %第j列，st、ed之间的所有行保留，其余清零 for k=1:tap_size st1=st+k-1; ed1=ed-k+1; if st1&gt;0; cg(st1,j)=cg(st1,j)*k/tap_size; end %在窗口外围至tap区域，逐渐削弱记录值 if ed1&lt;nt; cg(ed1,j)=cg(ed1,j)*k/tap_size; end end end end data(:,:,is)=cg; end 2.关闭指定 figurefigrue(i) %打开第i个图 plot... 画图 colse(figure(i)) % 关闭第i 个图 3.卷积互相关其中，只能处理连续放炮，不能处理间隔几个检波器放炮的情况。 代码： 成果图显示： for i=1:ns g=data(:,:,i); s=svshot(:,:,i); subplot(1,2,1); %wigg(g,3,dt,4); imagesc(g); caxis([-0.1 0.1]) title([&#39;Original CSG # &#39;,num2str(i)]); subplot(1,2,2); imagesc(s); caxis([-0.1 0.1]) title([&#39;Super Virtual CSG # &#39;,num2str(i)]); pause(0.5); end 4.repmat repmat Replicate and tile an array. B = repmat(A,M,N) or B = repmat(A,[M,N]) creates a large matrix B consisting of an M-by-N tiling of copies of A. If A is a matrix, the size of B is [size(A,1)*M, size(A,2)*N]. 三、测试四、打包发布命令行输入deploytool 需要matlab运行库的支持，支持库大小为621M , 若选用在线安装，则需再安装500M 运行库在线下载，速度过慢。 第一版完成日期： 2019.10.25","categories":[{"name":"Geophysics","slug":"Geophysics","permalink":"/categories/Geophysics/"}],"tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"/tags/MATLAB/"}],"keywords":[{"name":"Geophysics","slug":"Geophysics","permalink":"/categories/Geophysics/"}]},{"title":"vi learning","slug":"vi-learning","date":"2020-02-04T07:04:03.019Z","updated":"2020-02-04T13:03:34.677Z","comments":true,"path":"2020/02/04/vi-learning/","link":"","permalink":"/2020/02/04/vi-learning/","excerpt":"","text":"一、起因在使用清华镜像源时，需要修改pip文档 临时使用可以在使用pip的时候加参数-i https://pypi.tuna.tsinghua.edu.cn/simple例如：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple gevent，这样就会从清华这边的镜像去安装gevent库。 永久修改Linux下，修改 ~/.pip/pip.conf (没有就创建一个)， 修改 index-url至tuna，内容如下： [global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple windows下，直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，新建文件pip.ini，内容如下 [global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple 二、用法1、vi的基本操作a) 进入vi 在系统提示符号输入vi及文件名称后，就进入vi全屏幕编辑画面： $ vi myfile 不过有一点要特别注意，就是您进入vi之后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。初次使用vi的人都会想先用上下左右键移动光标，结果电脑一直哔哔叫，把自己气个半死，所以进入vi后，先不要乱动，转换到「插入模式（Insert mode）」再说吧！ b) 切换至插入模式（Insert mode）编辑文件 在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。 c) Insert 的切换 您目前处于「插入模式（Insert mode）」，您就只能一直输入文字，如果您发现输错了字！想用光标键往回移动，将该字删除，就要先按一下「ESC」键转到「命令行模式（command mode）」再删除文字。 d) 退出vi及保存文件 在「命令行模式（command mode）」下，按一下「：」冒号键进入「Last line mode」，例如： : w filename （输入 「w filename」将文章以指定的文件名filename保存） : wq (输入「wq」，存盘并退出vi) : q! (输入q!， 不存盘强制退出vi) 2、命令行模式（command mode）功能键1）. 插入模式​ 按「i」切换进入插入模式「insert mode」，按”i”进入插入模式后是从光标当前位置开始输入文件； 按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字； 按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。 2）. 从插入模式切换为命令行模式 按「ESC」键。 3）. 移动光标 vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。 按「ctrl」+「b」：屏幕往”后”移动一页。 按「ctrl」+「f」：屏幕往”前”移动一页。 按「ctrl」+「u」：屏幕往”后”移动半页。 按「ctrl」+「d」：屏幕往”前”移动半页。 按数字「0」：移到文章的开头。 按「G」：移动到文章的最后。 按「$」：移动到光标所在行的”行尾”。 按「^」：移动到光标所在行的”行首” 按「w」：光标跳到下个字的开头 按「e」：光标跳到下个字的字尾 按「b」：光标回到上个字的开头 按「#l」：光标移到该行的第#个位置，如：5l,56l。 4）. 删除文字 「x」：每按一次，删除光标所在位置的”后面”一个字符。 「#x」：例如，「6x」表示删除光标所在位置的”后面”6个字符。 「X」：大写的X，每按一次，删除光标所在位置的”前面”一个字符。 「#X」：例如，「20X」表示删除光标所在位置的”前面”20个字符。 「dd」：删除光标所在行。 「#dd」：从光标所在行开始删除#行 5）. 复制 「yw」：将光标所在之处到字尾的字符复制到缓冲区中。 「#yw」：复制#个字到缓冲区 「yy」：复制光标所在行到缓冲区。 「#yy」：例如，「6yy」表示拷贝从光标所在的该行”往下数”6行文字。 「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与”y”有关的复制命令都必须与”p”配合才能完成复制与粘贴功能。 6）. 替换 「r」：替换光标所在处的字符。 「R」：替换光标所到之处的字符，直到按下「ESC」键为止。 7）. 回复上一次操作 「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作。按多次”u”可以执行多次回复。 8）. 更改 「cw」：更改光标所在处的字到字尾处 「c#w」：例如，「c3w」表示更改3个字 9）. 跳至指定的行 「ctrl」+「g」列出光标所在行的行号。 「#G」：例如，「15G」，表示移动光标至文章的第15行行首。 3、Last line mode下命令简介 在使用「last line mode」之前，请记住先按「ESC」键确定您已经处于「command mode」下后，再按「：」冒号即可进入「last line mode」。 A) 列出行号 「set nu」：输入「set nu」后，会在文件中的每一行前面列出行号。 B) 跳到文件中的某一行 「#」：「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行。 C) 查找字符 「/关键字」：先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止。 「?关键字」：先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往前寻找到您要的关键字为止。 D) 保存文件 「w」：在冒号输入字母「w」就可以将文件保存起来。 E) 离开vi 「q」：按「q」就是退出，如果无法离开vi，可以在「q」后跟一个「!」强制离开vi。 「qw」：一般建议离开时，搭配「w」一起使用，这样在退出的时候还可以保存文件。 4、vi命令列表1、下表列出命令模式下的一些键的功能：a 在当前位置后插入 A 在当前行尾插入 i 在当前位置前插入 I 在当前行首插入 o 在当前行之后插入一行 O 在当前行之前插入一行，等价于ko j 下移一个字符 k 上移一个字符 h 左移一个字符 l 右移一个字符 $ 移动到行尾 n$ 移动到下边n行的行尾，即向下移动n行并到行尾 2、下表列出行命令模式下的一些指令 w filename 储存正在编辑的文件为filename wq filename 储存正在编辑的文件为filename，并退出vi q! 放弃所有修改，退出vi set nu 显示行号 /或? 查找，在/后输入要查找的内容 n 与/或?一起使用，如果查找的内容不是想要找的关键字，按n或向后（与/联用）或向前（与?联用）继续查找，直到找到为止。 对于第一次用vi，有几点注意要提醒一下： 1、用vi打开文件后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。切换方法：在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。 2、编辑好后，需从插入模式切换为命令行模式才能对文件进行保存，切换方法：按「ESC」键。 3、保存并退出文件：在命令模式下输入:wq即可！（别忘了wq前面的:） linux-Vi使用方法(备查)","categories":[{"name":"Fun","slug":"Fun","permalink":"/categories/Fun/"}],"tags":[],"keywords":[{"name":"Fun","slug":"Fun","permalink":"/categories/Fun/"}]},{"title":"Ubuntu下安装python2.7遇到的一些坑","slug":"Ubuntu下安装python2.7遇到的一些坑","date":"2020-02-04T07:04:03.017Z","updated":"2020-02-11T05:43:38.996Z","comments":true,"path":"2020/02/04/Ubuntu下安装python2.7遇到的一些坑/","link":"","permalink":"/2020/02/04/Ubuntu下安装python2.7遇到的一些坑/","excerpt":"","text":"使用清华镜像 临时使用 可以在使用pip的时候加参数-i https://pypi.tuna.tsinghua.edu.cn/simple 例如：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple gevent，这样就会从清华这边的镜像去安装gevent库。 永久修改 Linux下: 1、在用户目录下（/home/XXX）创建.pip文件夹，并创建pip.conf文件 ($mkdir .pip $touch pip.conf) 2、在pip.conf下输入：（注意：这里更换的是阿里云镜像源） (vi pip.conf) [global] # trusted-host = mirrors.aliyun.com index-url = http://mirrors.aliyun.com/pypi/simple 3、 sudo apt-get update windows下，直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，新建文件pip.ini，内容如下 [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple 坑1 numpy安装1.numpy 版本不支持 NumPy社区决定取消对Python 2.7的支持。Python 3.4支持也将随这个pull请求一起删除。所以现在，要使用NumPy 1.17和更新的版本，您需要Python 3.5或更高版本 解决方案 获取最新版本支持python2.7的numpy库： ​ pip install “ numpy &lt; 1.17 “ 2.缺少Python.h头文件无法通过编译，python2.7-dev无法安装 Numpy安装失败：缺少Python.h头文件 解决方案：安装python-dev Python-dev无法安装原因 出现这种原因是因为默认情况下Ubuntu中python2.7-dev提供的软件源与python-2.7.3-0ubuntu3.1的源不一值，python与python-dev的更新源不一致 解决方案 sudo apt-get update sudo apt-get upgrade sudo apt-get install python-dev 坑2 Matplotlib 安装1.版本不支持The upcoming version Matplotlib 3.0 will be Python 3 only. For Python 2 support, Matplotlib 2.2.x will be continued as a LTS release and updated with bugfixes until January 1, 2020. 2.依赖关系依赖关系不好找，freetype,安装时需要sudo 权限，安装提示安装sudo apt-get install即可 坑3 Scipy 安装版本需要scipy 最新为 1.2.2 $ sudo pip install “scipy &lt; 2.0” 安装pip3 sudo apt-get install python3-pip 升级pip3 sudo pip3 install –upgrade pip 卸载pip3 sudo apt-get remove python3-pip anaconda 安装$sudo sh Anaconda3-5.2.0-Linux-x86_64.sh","categories":[{"name":"Fun","slug":"Fun","permalink":"/categories/Fun/"}],"tags":[{"name":"Fun","slug":"Fun","permalink":"/tags/Fun/"}],"keywords":[{"name":"Fun","slug":"Fun","permalink":"/categories/Fun/"}]},{"title":"python 数据处理","slug":"python-数据处理","date":"2020-02-04T07:01:00.313Z","updated":"2020-02-04T13:03:06.529Z","comments":true,"path":"2020/02/04/python-数据处理/","link":"","permalink":"/2020/02/04/python-数据处理/","excerpt":"","text":"[TOC] 一、matplotlib1. ion()和ioff()python可视化库matplotlib有两种显示模式： 阻塞（block）模式（脚本中默认） 交互（interactive）模式（命令行中默认） 在交互模式下： plt.plot(x)或plt.imshow(x)是直接出图像，不需要plt.show() 如果在脚本中使用ion()命令开启了交互模式，没有使用ioff()关闭的话，则图像会一闪而过，并不会常留。要想防止这种情况，需要在plt.show()之前加上ioff()命令。 在阻塞模式下： 打开一个窗口以后必须关掉才能打开下一个新的窗口。这种情况下，默认是不能像Matlab一样同时开很多窗口进行对比的。 plt.plot(x)或plt.imshow(x)是直接出图像，需要plt.show()后才能显示图像 2. imshow()matplotlib.pyplot.imshow (X, cmap=None, norm=None, aspect=None, interpolation=None, alpha=None, vmin=None, vmax=None, origin=None, extent=None, shape=, filternorm=1, filterrad=4.0, imlim=, resample=None, url=None, , data=None, kwargs*) (1)cmap设置 cmap 的几种方式： plt.imshow(image, cmap=plt.get_cmap(&#39;gray_r&#39;)) plt.imshow(image, cmap=&#39;gray_r&#39;) plt.imshow(image, cmap=plt.cm.binary) cmap的候选值： &#39;Accent&#39;, &#39;Accent_r&#39;, &#39;Blues&#39;, &#39;Blues_r&#39;, &#39;BrBG&#39;, &#39;BrBG_r&#39;, &#39;BuGn&#39;, &#39;BuGn_r&#39;, &#39;BuPu&#39;, &#39;BuPu_r&#39;, &#39;CMRmap&#39;, &#39;CMRmap_r&#39;, &#39;Dark2&#39;, &#39;Dark2_r&#39;, &#39;GnBu&#39;, &#39;GnBu_r&#39;, &#39;Greens&#39;, &#39;Greens_r&#39;, &#39;Greys&#39;, &#39;Greys_r&#39;, &#39;OrRd&#39;, &#39;OrRd_r&#39;, &#39;Oranges&#39;, &#39;Oranges_r&#39;, &#39;PRGn&#39;, &#39;PRGn_r&#39;, &#39;Paired&#39;, &#39;Paired_r&#39;, &#39;Pastel1&#39;, &#39;Pastel1_r&#39;, &#39;Pastel2&#39;, &#39;Pastel2_r&#39;, &#39;PiYG&#39;, &#39;PiYG_r&#39;, &#39;PuBu&#39;, &#39;PuBuGn&#39;, &#39;PuBuGn_r&#39;, &#39;PuBu_r&#39;, &#39;PuOr&#39;, &#39;PuOr_r&#39;, &#39;PuRd&#39;, &#39;PuRd_r&#39;, &#39;Purples&#39;, &#39;Purples_r&#39;, &#39;RdBu&#39;, &#39;RdBu_r&#39;, &#39;RdGy&#39;, &#39;RdGy_r&#39;, &#39;RdPu&#39;, &#39;RdPu_r&#39;, &#39;RdYlBu&#39;, &#39;RdYlBu_r&#39;, &#39;RdYlGn&#39;, &#39;RdYlGn_r&#39;, &#39;Reds&#39;, &#39;Reds_r&#39;, &#39;Set1&#39;, &#39;Set1_r&#39;, &#39;Set2&#39;, &#39;Set2_r&#39;, &#39;Set3&#39;, &#39;Set3_r&#39;, &#39;Spectral&#39;, &#39;Spectral_r&#39;, &#39;Vega10&#39;, &#39;Vega10_r&#39;, &#39;Vega20&#39;, &#39;Vega20_r&#39;, &#39;Vega20b&#39;, &#39;Vega20b_r&#39;, &#39;Vega20c&#39;, &#39;Vega20c_r&#39;, &#39;Wistia&#39;, &#39;Wistia_r&#39;, &#39;YlGn&#39;, &#39;YlGnBu&#39;, &#39;YlGnBu_r&#39;, &#39;YlGn_r&#39;, &#39;YlOrBr&#39;, &#39;YlOrBr_r&#39;, &#39;YlOrRd&#39;, &#39;YlOrRd_r&#39;, &#39;afmhot&#39;, &#39;afmhot_r&#39;, &#39;autumn&#39;, &#39;autumn_r&#39;, &#39;binary&#39;, &#39;binary_r&#39;, &#39;bone&#39;, &#39;bone_r&#39;, &#39;brg&#39;, &#39;brg_r&#39;, &#39;bwr&#39;, &#39;bwr_r&#39;, &#39;cool&#39;, &#39;cool_r&#39;, &#39;coolwarm&#39;, &#39;coolwarm_r&#39;, &#39;copper&#39;, &#39;copper_r&#39;, &#39;cubehelix&#39;, &#39;cubehelix_r&#39;, &#39;flag&#39;, &#39;flag_r&#39;, &#39;gist_earth&#39;, &#39;gist_earth_r&#39;, &#39;gist_gray&#39;, &#39;gist_gray_r&#39;, &#39;gist_heat&#39;, &#39;gist_heat_r&#39;, &#39;gist_ncar&#39;, &#39;gist_ncar_r&#39;, &#39;gist_rainbow&#39;, &#39;gist_rainbow_r&#39;, &#39;gist_stern&#39;, &#39;gist_stern_r&#39;, &#39;gist_yarg&#39;, &#39;gist_yarg_r&#39;, &#39;gnuplot&#39;, &#39;gnuplot2&#39;, &#39;gnuplot2_r&#39;, &#39;gnuplot_r&#39;, &#39;gray&#39;, &#39;gray_r&#39;, &#39;hot&#39;, &#39;hot_r&#39;, &#39;hsv&#39;, &#39;hsv_r&#39;, &#39;inferno&#39;, &#39;inferno_r&#39;, &#39;jet&#39;, &#39;jet_r&#39;, &#39;magma&#39;, &#39;magma_r&#39;, &#39;nipy_spectral&#39;, &#39;nipy_spectral_r&#39;, &#39;ocean&#39;, &#39;ocean_r&#39;, &#39;pink&#39;, &#39;pink_r&#39;, &#39;plasma&#39;, &#39;plasma_r&#39;, &#39;prism&#39;, &#39;prism_r&#39;, &#39;rainbow&#39;, &#39;rainbow_r&#39;, &#39;seismic&#39;, &#39;seismic_r&#39;, &#39;spectral&#39;, &#39;spectral_r&#39;, &#39;spring&#39;, &#39;spring_r&#39;, &#39;summer&#39;, &#39;summer_r&#39;, &#39;tab10&#39;, &#39;tab10_r&#39;, &#39;tab20&#39;, &#39;tab20_r&#39;, &#39;tab20b&#39;, &#39;tab20b_r&#39;, &#39;tab20c&#39;, &#39;tab20c_r&#39;, &#39;terrain&#39;, &#39;terrain_r&#39;, &#39;viridis&#39;, &#39;viridis_r&#39;, &#39;winter&#39;, &#39;winter_r&#39; 如果 gray 将图像显示为黑底白字，gray_r 会将其显示为白底黑字； (2)aspect, vmin=true_impedance.min(), vmaxaspect : {‘equal’, ‘auto’} or float, optional 更改纵横比（aspect ratio） Controls the aspect ratio of the axes. The aspect is of particular relevance for images since it may distort the image, i.e. pixel will not be square. This parameter is a shortcut for explicitly calling Axes.set_aspect. See there for further details. ‘equal’: Ensures an aspect ratio of 1. Pixels will be square (unless pixel sizes are explicitly made non-square in data coordinates using extent). ‘auto’: The axes is kept fixed and the aspect is adjusted so that the data fit in the axes. In general, this will result in non-square pixels. If not given, use rcParams[&quot;image.aspect&quot;] = &#39;equal&#39; (default: ‘equal’). (3)vmin,vmaxvmin, vmax : scalar, optional When using scalar data and no explicit norm, vmin and vmax define the data range that the colormap covers. By default, the colormap covers the complete value range of the supplied data. vmin, vmax are ignored if the norm parameter is used. 3.matplotlib.pyplotplt.scatter(x,y,1) 1 表示散点的粗细大小 （1）坐标轴翻转import matplotlib.pyplot as plt ax = plt.gca() ax.invert_xaxis() plt.plot(range(10),range(10)) plt.show() （2）更改坐标轴位置及不显示某个坐标轴由于axes会获取到四个轴，而我们只需要两个轴，所以我们需要把另外两个轴隐藏，把顶部和右边轴的颜色设置为none，将不会显示。 ax.spines[&#39;right&#39;].set_color(&#39;none&#39;) ax.spines[&#39;top&#39;].set_color(&#39;none&#39;) # 使顶部坐标轴不显示 ax.spines[‘bottom’]获取底部的轴，通过set_position方法，设置底部轴的位置，例如：ax.spines[‘bottom’].set_position((‘data’,0))表示设置底部轴移动到竖轴的0坐标位置，设置left的方法相同 . # 设置底边的移动范围，移动到y轴的0位置 # data:移动轴的位置到交叉轴的指定坐标 outward:不太懂 axes:0.0 - 1.0之间的值，整个轴上的比例 # center:(&#39;axes&#39;,0.5) zero:(&#39;data&#39;,0.0) ax.spines[&#39;bottom&#39;].set_position((&#39;data&#39;, 0)) ax.spines[&#39;left&#39;].set_position((&#39;data&#39;,0)) （3）设置坐标轴显示范围及修改label# 利用axes对象设置轴线的显示范围，与plt.xlim(-1,2)和plt.ylim(-2,3)的作用相同 ax.set_xlim(-1,2) ax.set_ylim(-2,3) # 利用axes对象设置坐标轴的标签 ax.set_xlabel(&#39;x data&#39;) ax.set_ylabel(&#39;y data&#39;) （4）ticks显示问题数字和小tick 共同改变至所在坐标轴位置 # 设置坐标轴上的数字显示的位置，top:显示在顶部 bottom:显示在底部,默认是none ax.xaxis.set_ticks_position(&#39;top&#39;) ax.yaxis.set_ticks_position(&#39;none&#39;) Tick的方向有三种，一种为in，另外一种为out，还有一种是inout。 更改Tick的朝向： # 设置xtick和ytick的方向：in、out、inout plt.rcParams[&#39;xtick.direction&#39;] = &#39;in&#39; plt.rcParams[&#39;ytick.direction&#39;] = &#39;in&#39; #以下代码起作用 ax1.tick_params(direction=&#39;in&#39;,width=2,length=4,colors=&#39;gold&#39;) 使 x,y 坐标不显示 plt.plot(x,y) ax = plt.gca() ax.set_xticks([]) （5）不显示坐标的值# 生成网格 ax.grid(True) # 取消标签的数字显示 ax.tick_params(&#39;y&#39;, labelleft=False) # 取消left即可（top，bottom，right） plt.show() （6）绘制等高线# -*- coding:utf-8 -*- #引入numpy库和matplotlib库 import numpy as np import matplotlib.pyplot as plt # 定义等高线图的横纵坐标x，y #从左边取值为从 -3 到 3 ，各取5个点，一共取 5*5 = 25 个点 x = np.linspace(-3, 3, 5) y = np.linspace(-3, 3, 5) # 将原始数据变成网格数据 X, Y = np.meshgrid(x, y) # 各地点对应的高度数据 #Height是个 5*5 的数组，记录地图上 25 个点的高度汇总 Height = [[0,0,1,2,2],[0,-2,-2,1,5],[4,2,6,8,1],[3,-3,-3,0,5],[1,-5,-2,0,3]] # 填充颜色 plt.contourf(X, Y, Height, 10, alpha = 0.6, cmap = plt.cm.hot) # 绘制等高线 C = plt.contour(X, Y, Height, 10, colors = &#39;black&#39;, linewidth = 0.5) # 显示各等高线的数据标签 plt.clabel(C, inline = True, fontsize = 10) plt.show() contourf 填充颜色函数 前三个参数 X, Y, Height 用来引进点的位置和对应的高度数据； 数字 10 代表将等高线图分成10块（这里不是硬性要求，但数值过小会造成部分分区颜色区分度不高）； alpha = 0.6 用来设置填充颜色的范围，alpha取值为 [0,1) 。alpha=0时，画出的是无色图，alpha越接近1，颜色的搭配就越向深色风格过渡 #只画z=20和40的线，并将颜色设置为黑色 contour = plt.contour(X,Y,Z,[20,40],colors=&#39;k&#39;) #等高线上标明z（即高度）的值，字体大小是10，颜色分别是黑色和红色 plt.clabel(contour,fontsize=10,colors=(&#39;k&#39;,&#39;r&#39;)) （7）显示titleax.set_title(&#39;name&#39;) 4.pyplot.subplots 在matplotlib中，整个图像为一个Figure对象。在Figure对象中可以包含一个或者多个Axes对象。每个Axes(ax)对象都是一个拥有自己坐标系统的绘图区域。 参数 nrows，ncols： 子图的行列数。 sharex, sharey： 设置为 True 或者 ‘all’ 时，所有子图共享 x 轴或者 y 轴， 设置为 False or ‘none’ 时，所有子图的 x，y 轴均为独立， 设置为 ‘row’ 时，每一行的子图会共享 x 或者 y 轴， 设置为 ‘col’ 时，每一列的子图会共享 x 或者 y 轴。 ax.flatten() 例如: fig,ax = plt.subplots(nrows=2, ncols=2) axes = ax.flatten() 把子图展开赋值给axes,axes[0]便是第一个子图，axes[1]是第二个… … 应用实例: import matplotlib.pyplot as plt fig, ax = plt.subplots( nrows=2, ncols=5, sharex=True, sharey=True, ) ax = ax.flatten() for i in range(10): img = X_train[y_train == i][0].reshape(28, 28) ax[i].imshow(img, cmap=&#39;Greys&#39;, interpolation=&#39;nearest&#39;) ax[0].set_xticks([]) ax[0].set_yticks([]) plt.tight_layout() plt.show() fig.tight_layout()有多个plots的时候，会出现重叠的现象，通过tight_layout可以解决 tight_layout可以通过参数pad, w_pad, h_pad来设置一些布局的细节 5. annotate() ax.annotate(row,xy=(0,0.5), xytext=(-pad,0), xycoords=’axes fraction’, textcoords=’offset points’, ha=’right’, va=’center’) 当图线中某些特殊地方需要标注时，我们可以使用 annotation. matplotlib 中的 annotation 有两种方法， 一种是用 plt 里面的 annotate，一种是直接用 plt 里面的 text 来写标注. 然后标注出点(x0, y0)的位置信息. 用plt.plot([x0, x0,], [0, y0,], &#39;k--&#39;, linewidth=2.5) 画出一条垂直于x轴的虚线. 接下来我们就对(x0, y0)这个点进行标注. plt.annotate(r&#39;$2x+1=%s$&#39; % y0, xy=(x0, y0), xycoords=&#39;data&#39;, xytext=(+30, -30), textcoords=&#39;offset points&#39;, fontsize=16, arrowprops=dict(arrowstyle=&#39;-&gt;&#39;, connectionstyle=&quot;arc3,rad=.2&quot;)) 其中参数xycoords=&#39;data&#39; 是说基于数据的值来选位置, xytext=(+30, -30) 和 textcoords=&#39;offset points&#39; 对于标注位置的描述 和 xy 偏差值, arrowprops是对图中箭头类型的一些设置. 添加注释 text plt.text(-3.7, 3, r&#39;$This\\ is\\ the\\ some\\ text. \\mu\\ \\sigma_i\\ \\alpha_t$&#39;, fontdict={&#39;size&#39;: 16, &#39;color&#39;: &#39;r&#39;}) 其中-3.7, 3,是选取text的位置, 空格需要用到转字符\\,fontdict设置文本字体. 6.violinplotnp.random.seed(1) plt.violinplot(dataset=np.random.randn(200,10) + np.random.randn(10)) 二、numpy1. 运算符号 函数 描述 dot 两个数组的点积，即元素对应相乘。 vdot 两个向量的点积 inner 两个数组的内积 matmul 两个数组的矩阵积 determinant 数组的行列式 solve 求解线性矩阵方程 inv 计算矩阵的乘法逆矩阵 1）向量、矩阵叉乘numpy.dot() numpy.dot() 对于两个一维的数组，计算的是这两个数组对应下标元素的乘积和(数学上称之为内积)；对于二维数组，计算的是两个数组的矩阵乘积；对于多维数组，它的通用计算公式如下，即结果数组中的每个元素都是：数组a的最后一维上的所有元素与数组b的倒数第二位上的所有元素的乘积和： dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])。 numpy.dot(a, b, out=None) 参数说明： a : ndarray 数组 b : ndarray 数组 out : ndarray, 可选，用来保存dot()的计算结果 2)二维矩阵对应元素相乘（*乘） 有2种方式，一个是np.multiply(a,b)，另外一个是* 。 import numpy a = numpy.array([[1,2], [3,4]]) b = numpy.array([[5,6], [7,8]]) a*b &gt;&gt;&gt;array([[ 5, 12], [21, 32]]) a.dot(b) &gt;&gt;&gt;array([[19, 22], [43, 50]]) numpy.dot(a,b) &gt;&gt;&gt;array([[19, 22], [43, 50]]) 3）计算平方，乘方，平方根# 计算乘方 pow(4,3) # 计算平方 pow(5,2) import numpy numpy.square(5) # 计算平方根 pow(25,0.5) import numpy numpy.sqrt(25) import math math.sqrt(25) 对于numpy定义的向量array变量，如果求其exp，需要使用np.exp()，不能使用 math.exp() ，否则报错。 2. 矩阵拼接import numpy as np a=np.array([[1,2,3],[4,5,6]]) b=np.array([[11,12,31],[14,15,16]]) #方法1 c=np.r_[a,b] #沿着矩阵行拼接 print(&#39;c=&#39;,c) d=np.c_[a,b] #沿着矩阵列拼接 print(&#39;d=&#39;,d) #方法2 e=np.vstack((a,b)) #沿着矩阵行拼接 print(&#39;e=&#39;,e) f=np.hstack((a,b)) #沿着矩阵列拼接 print(&#39;f=&#39;,f) #out c= [[ 1 2 3] [ 4 5 6] [11 12 31] [14 15 16]] d= [[ 1 2 3 11 12 31] [ 4 5 6 14 15 16]] e= [[ 1 2 3] [ 4 5 6] [11 12 31] [14 15 16]] f= [[ 1 2 3 11 12 31] [ 4 5 6 14 15 16]] 在使用numpy进行矩阵拼接之时，由于 numpy会申请连续的内存，如果频繁改变大小，他就要频繁申请新的内存 numpy的数组一旦变动大小就会像搬家一样大包小包的带着自己的全部数据，拉家带口的搬到新家，所以，才需要你一开始就将numpy数组的大小设定好。 NumPy数组与列表是一个非常不同的数据结构，它被设计用于不同的方式。 你对 hstack的使用可能非常低效。 每次调用它时，现有数组中的所有数据都将复制到新数组中。 (append 函数会有同样的问题。) 因此，最好把它放在一个列表中，直到它完成，然后将它转换成数组。 import numpy as np a=[] a.append(2) b=np.array(a) 可以直接使用 list 进行拼接之后再抓换位numpy中的变量. a = [1,2,3] b = [4,5,6] d = np.array([a,b]) d.shape #d为2x3的数组,d=[[1,2,3], # [4,5,6]] 3） 3. 创建矩阵创建的数据默认是float类型 np.zeros中第一个参数是shape=XX，代表创建的是几维的数组，第二个参数代表的是数据类型，dtype=int代表的是传入整数类型。 np.ones代表里面的数值全为1 np.full代表的是数值全为指定数的值 numpy中arange的使用 numpy.arrange(0:20:2)步长为2，前闭后开区间，所以不包含20 arange和range的最大不同是range不能传入小数 np.zeros((2,2)) 矩阵加法np 的矩阵，可以（3，4）+（3，4）即同等大小直接对应元素相加；也可以（3，4）+（4，），即列数对应相同，每一列相加同样的元素；或者（3，4）+ （1），给每个元素增加同样的元素 np.ones((3,5))+np.random.randn(3,5) np.ones((3,5))+np.random.randn(5) np.ones((3,5))+np.random.randn(1) np.random.seed(1) print(&quot;+(3,5)\\n&quot;,np.ones((3,5))+np.random.randn(3,5)) print(&quot;+(5,)\\n&quot;,np.ones((3,5))+np.random.randn(5)) print(&quot;+(1，)\\n&quot;,np.ones((3,5))+np.random.randn(1)) &quot;&quot;&quot; +(3,5) [[ 2.62434536 0.38824359 0.47182825 -0.07296862 1.86540763] [-1.3015387 2.74481176 0.2387931 1.3190391 0.75062962] [ 2.46210794 -1.06014071 0.6775828 0.61594565 2.13376944]] +(5,) [[-0.09989127 0.82757179 0.12214158 1.04221375 1.58281521] [-0.09989127 0.82757179 0.12214158 1.04221375 1.58281521] [-0.09989127 0.82757179 0.12214158 1.04221375 1.58281521]] +(1，) [[-0.10061918 -0.10061918 -0.10061918 -0.10061918 -0.10061918] [-0.10061918 -0.10061918 -0.10061918 -0.10061918 -0.10061918] [-0.10061918 -0.10061918 -0.10061918 -0.10061918 -0.10061918]] &quot;&quot;&quot; 4. np.random 随机 简单随机数： 产生简单的随机数据，可以是任何维度 排列：将所给对象随机排列 分布：产生指定分布的数据，如高斯分布等 生成器：种随机数种子，根据同一种子产生的随机数是相同的 1)生成器电脑产生随机数需要明白以下几点：（1）随机数是由随机种子根据一定的计算方法计算出来的数值。所以，只要计算方法一定，随机种子一定，那么产生的随机数就不会变。（2）只要用户不设置随机种子，那么在默认情况下随机种子来自系统时钟（即定时/计数器的值）（3）随机数产生的算法与系统有关，Windows和Linux是不同的，也就是说，即便是随机种子一样，不同系统产生的随机数也不一样。numpy.random 设置种子的方法有： 函数名称 函数功能 参数说明 RandomState 定义种子类 RandomState是一个种子类，提供了各种种子方法，最常用seed seed([seed]) 定义全局种子 参数为整数或者矩阵 代码示例： np.random.seed(1234) #设置随机种子为1234 2)简单随机 函数名称 函数功能 参数说明 rand(d0, d1, …, dn) 产生均匀分布的随机数 dn为第n维数据的维度 randn(d0, d1, …, dn) 产生标准正态分布随机数 dn为第n维数据的维度 randint(low[, high, size, dtype]) 产生随机整数 low：最小值；high：最大值；size：数据个数 random_sample([size]) 在[0,1）内产生随机数 size：随机数的shape，可以为元祖或者列表，[2,3]表示2维随机数，维度为（2,3） random([size]) 同random_sample([size]) 同random_sample([size]) ranf([size]) 同random_sample([size]) 同random_sample([size]) sample([size])) 同random_sample([size]) 同random_sample([size]) choice(a[, size, replace, p]) 从a中随机选择指定数据 a：1维数组 size：返回数据形状 bytes(length) 返回随机位 length：位的长度 3)分布 (经典概率分布) 函数名称 函数功能 参数说明 beta(a, b[, size]) 贝塔分布样本，在 [0, 1]内。 binomial(n, p[, size]) 二项分布的样本。 chisquare(df[, size]) 卡方分布样本。 dirichlet(alpha[, size]) 狄利克雷分布样本。 exponential([scale, size]) 指数分布 f(dfnum, dfden[, size]) F分布样本。 gamma(shape[, scale, size]) 伽马分布 geometric(p[, size]) 几何分布 gumbel([loc, scale, size]) 耿贝尔分布。 hypergeometric(ngood, nbad, nsample[, size]) 超几何分布样本。 laplace([loc, scale, size]) 拉普拉斯或双指数分布样本 logistic([loc, scale, size]) Logistic分布样本 lognormal([mean, sigma, size]) 对数正态分布 logseries(p[, size]) 对数级数分布。 multinomial(n, pvals[, size]) 多项分布 multivariate_normal(mean, cov[, size]) 多元正态分布。 negative_binomial(n, p[, size]) 负二项分布 noncentral_chisquare(df, nonc[, size]) 非中心卡方分布 noncentral_f(dfnum, dfden, nonc[, size]) 非中心F分布 normal([loc, scale, size]) 正态(高斯)分布 pareto(a[, size]) 帕累托（Lomax）分布 poisson([lam, size]) 泊松分布 power(a[, size]) Draws samples in [0, 1] from a power distribution with positive exponent a - 1. rayleigh([scale, size]) Rayleigh 分布 standard_cauchy([size]) 标准柯西分布 standard_exponential([size]) 标准的指数分布 standard_gamma(shape[, size]) 标准伽马分布 standard_normal([size]) 标准正态分布 (mean=0, stdev=1). standard_t(df[, size]) Standard Student’s t distribution with df degrees of freedom. triangular(left, mode, right[, size]) 三角形分布 uniform([low, high, size]) 均匀分布 vonmises(mu, kappa[, size]) von Mises分布 wald(mean, scale[, size]) 瓦尔德（逆高斯）分布 weibull(a[, size]) Weibull 分布 zipf(a[, size]) 齐普夫分布 4)排列 (打乱对象) 函数名称 函数功能 参数说明 shuffle(x) 打乱对象x（多维矩阵按照第一维打乱） 矩阵或者列表 permutation(x) 打乱并返回该对象（多维矩阵按照第一维打乱） 整数或者矩阵 5. FFT6. np.newaxisnp.newaxis的功能是插入新维度，例如：b=x_np[np.newaxis, :, np.newaxis] 输出结果 ([1, 10, 1]) 7. np.flattenndarray.flatten(order=’C’) Return a copy of the array collapsed into one dimension. 将矩阵压扁成一维 8. numpy.load() 存取data = numpy.load (&quot;path&quot;) data 一般为 numpy.ndarray 形式的数据，若要将其转变为字典形式，则应为 data = numpy.load(&quot;path&quot;).item() 9.numpy 中的常数（1）infnumpy中的inf表示一个无限大的正数 import numpy x = numpy.inf x&gt;9999999999999999999 10. 求均值等np.mean(a ,axis=(0,-1),keepdims = True) 其中，a 为求均值的 ndarray ,axis 表示需要求均值的坐标维度，默认将所有维度flatten 后求和， keepdims 表示将各维度保持原样求均值。","categories":[{"name":"Fun","slug":"Fun","permalink":"/categories/Fun/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}],"keywords":[{"name":"Fun","slug":"Fun","permalink":"/categories/Fun/"}]},{"title":"python 拾遗","slug":"python-拾遗","date":"2020-02-04T07:00:25.249Z","updated":"2020-02-11T05:45:37.028Z","comments":true,"path":"2020/02/04/python-拾遗/","link":"","permalink":"/2020/02/04/python-拾遗/","excerpt":"","text":"[TOC] 1. super函数与子类继承父类构造函数情况一：子类需要自动调用父类的方法：子类不重写init()方法，实例化子类后，会自动调用父类的init()的方法。 情况二：子类不需要自动调用父类的方法：子类重写init()方法，实例化子类后，将不会自动调用父类的init()的方法。 情况三：子类重写init()方法又需要调用父类的方法：使用super关键词： 例子: ```python class Father(object): def __init__(self, name): self.name=name print ( &quot;name: %s&quot; %( self.name) ) def getName(self): return &#39;Father &#39; + self.name class Son(Father): def __init__(self, name): print ( &quot;hi&quot; ) self.name = name def getName(self): return &#39;Son &#39;+self.name if __name__==&#39;__main__&#39;: son=Son(&#39;runoob&#39;) print ( son.getName() ) &quot;&quot;&quot; hi Son runoob &quot;&quot;&quot; class Father(object): def __init__(self, name): self.name=name print ( &quot;name: %s&quot; %( self.name)) def getName(self): return &#39;Father &#39; + self.name class Son(Father): def __init__(self, name): super(Son, self).__init__(name) print (&quot;hi&quot;) self.name = name def getName(self): return &#39;Son &#39;+self.name if __name__==&#39;__main__&#39;: son=Son(&#39;runoob&#39;) print ( son.getName() ) &quot;&quot;&quot; name: runoob hi Son runoob &quot;&quot;&quot; 在类的继承里面super()非常常用， 它解决了子类调用父类方法的一些问题， 父类多次被调用时只执行一次， 优化了执行逻辑，下面我们就来详细看一下。 举一个例子： class Foo: def bar(self, message): print(message) &gt;&gt;&gt; Foo().bar(&quot;Hello, Python.&quot;) Hello, Python. 当存在继承关系的时候，有时候需要在子类中调用父类的方法，此时最简单的方法是把对象调用转换成类调用，需要注意的是这时self参数需要显式传递，例如： class FooParent: def bar(self, message): print(message) class FooChild(FooParent): def bar(self, message): FooParent.bar(self, message) &gt;&gt;&gt; FooChild().bar(&quot;Hello, Python.&quot;) Hello, Python. 这样做有一些缺点，比如说如果修改了父类名称，那么在子类中会涉及多处修改，另外，Python是允许多继承的语言，如上所示的方法在多继承时就需要重复写多次，显得累赘。为了解决这些问题，Python引入了super()机制，例子代码如下： class FooParent: def bar(self, message): print(message) class FooChild(FooParent): def bar(self, message): super(FooChild, self).bar(message) &gt;&gt;&gt; FooChild().bar(&quot;Hello, Python.&quot;) Hello, Python 表面上看 super(FooChild, self).bar(message)方法和FooParent.bar(self, message)方法的结果是一致的，实际上这两种方法的内部处理机制大大不同，当涉及多继承情况时，就会表现出明显的差异来，直接给例子：代码一： class A: def __init__(self): print(&quot;Enter A&quot;) print(&quot;Leave A&quot;) class B(A): def __init__(self): print(&quot;Enter B&quot;) A.__init__(self) print(&quot;Leave B&quot;) class C(A): def __init__(self): print(&quot;Enter C&quot;) A.__init__(self) print(&quot;Leave C&quot;) class D(A): def __init__(self): print(&quot;Enter D&quot;) A.__init__(self) print(&quot;Leave D&quot;) class E(B, C, D): def __init__(self): print(&quot;Enter E&quot;) B.__init__(self) C.__init__(self) D.__init__(self) print(&quot;Leave E&quot;)E() 结果：Enter EEnter BEnter ALeave ALeave BEnter CEnter ALeave ALeave CEnter DEnter ALeave ALeave DLeave E 执行顺序很好理解，唯一需要注意的是公共父类A被执行了多次。 代码二： class A: def __init__(self): print(&quot;Enter A&quot;) print(&quot;Leave A&quot;) class B(A): def __init__(self): print(&quot;Enter B&quot;) super(B, self).__init__() print(&quot;Leave B&quot;) class C(A): def __init__(self): print(&quot;Enter C&quot;) super(C, self).__init__() print(&quot;Leave C&quot;) class D(A): def __init__(self): print(&quot;Enter D&quot;) super(D, self).__init__() print(&quot;Leave D&quot;) class E(B, C, D): def __init__(self): print(&quot;Enter E&quot;) super(E, self).__init__() print(&quot;Leave E&quot;)E() 结果： Enter E Enter B Enter C Enter D Enter A Leave A Leave D Leave C Leave B Leave E 在super机制里可以保证公共父类仅被执行一次，至于执行的顺序，是按照MRO（Method Resolution Order）：方法解析顺序 进行的。 2. enumerate()enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。 以下是 enumerate() 方法的语法: enumerate(sequence, [start=0]) （1）参数 sequence – 一个序列、迭代器或其他支持迭代对象。 start – 下标起始位置。 （2）返回值 返回 enumerate(枚举) 对象。 实例 以下展示了使用 enumerate() 方法的实例： &gt;&gt;&gt;seasons = [&#39;Spring&#39;, &#39;Summer&#39;, &#39;Fall&#39;, &#39;Winter&#39;] &gt;&gt;&gt; list(enumerate(seasons)) [(0, &#39;Spring&#39;), (1, &#39;Summer&#39;), (2, &#39;Fall&#39;), (3, &#39;Winter&#39;)] &gt;&gt;&gt; list(enumerate(seasons, start=1)) # 下标从 1 开始 [(1, &#39;Spring&#39;), (2, &#39;Summer&#39;), (3, &#39;Fall&#39;), (4, &#39;Winter&#39;)] （3）for 循环使用 enumerateseq = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;] for i, element in enumerate(seq): print i, element &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 0 one 1 two 2 three 3.zip()zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。 我们可以使用 list() 转换来输出列表。 如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。 list(zip(a,b)与*zip(a,b) 效果等价 zip 语法： zip([iterable, ...]) 参数说明： iterabl – 一个或多个迭代器; 以下实例展示了 zip 的使用方法： &gt;&gt;&gt;a = [1,2,3] &gt;&gt;&gt; b = [4,5,6] &gt;&gt;&gt; c = [4,5,6,7,8] &gt;&gt;&gt; zipped = zip(a,b) # 返回一个对象 &gt;&gt;&gt; zipped &lt;zip object at 0x103abc288&gt; &gt;&gt;&gt; list(zipped) # list() 转换为列表 [(1, 4), (2, 5), (3, 6)] &gt;&gt;&gt; list(zip(a,c)) # 元素个数与最短的列表一致 [(1, 4), (2, 5), (3, 6)] &gt;&gt;&gt; a1, a2 = zip(*zip(a,b)) # 与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式 &gt;&gt;&gt; list(a1) [1, 2, 3] &gt;&gt;&gt; list(a2) [4, 5, 6] 将x个y维列表打包变成一个zip对象，将zip对象拆包可以发现它变成了y个x维元组。我们还可以将这个对象变成一个元组或列表。 如果是两个列表的zip，我们还可以将其变成字典形式。 下面是一个小实例： name = [&#39;wl&#39;,&#39;lyf&#39;,&#39;hg&#39;] old = [22,33,35] for i,j in zip(name,old): print(&quot;他叫{},今年{}岁&quot;.format(i,j)) 他叫wl,今年22岁 他叫lyf,今年33岁 他叫hg,今年35岁 要注意的是，如果使用zip函数，一定要确保多个列表的元素数是相同的，不然对于多出的部分因无法匹配会自动丢弃掉 4.字典（1）items()items()方法语法： 返回值: 返回可遍历的(键, 值) 元组数组。 ```python dict = {&#39;Google&#39;: &#39;www.google.com&#39;, &#39;Runoob&#39;: &#39;www.runoob.com&#39;, &#39;taobao&#39;: &#39;www.taobao.com&#39;} print &quot;字典值 : %s&quot; % dict.items() # 遍历字典列表 for key,values in dict.items(): print key,values # 输出结果 # 字典值 : [(&#39;Google&#39;, &#39;www.google.com&#39;), (&#39;taobao&#39;, &#39;www.taobao.com&#39;), (&#39;Runoob&#39;, &#39;www.runoob.com&#39;)] # Google www.google.com # taobao www.taobao.com # Runoob www.runoob.com （2）基本概念字典是另一种可变容器模型，且可存储任意类型对象。 字典的每个键值 key=&gt;value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中 ,格式如下所示 值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。 把相应的键放入熟悉的方括弧 dict = {&#39;Name&#39;: &#39;Zara&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;} print &quot;dict[&#39;Name&#39;]: &quot;, dict[&#39;Name&#39;] print &quot;dict[&#39;Age&#39;]: &quot;, dict[&#39;Age&#39;] 能删单一的元素也能清空字典，清空只需一项操作。 显示删除一个字典用del命令，如下实例： dict = {&#39;Name&#39;: &#39;Zara&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;} del dict[&#39;Name&#39;] # 删除键是&#39;Name&#39;的条目 dict.clear() # 清空字典所有条目 del dict # 删除字典 print &quot;dict[&#39;Age&#39;]: &quot;, dict[&#39;Age&#39;] print &quot;dict[&#39;School&#39;]: &quot;, dict[&#39;School&#39;] （3）内置函数及方法Python字典包含了以下内置函数： 序号 函数及描述 1 cmp(dict1, dict2) 比较两个字典元素。 2 len(dict) 计算字典元素个数，即键的总数。 3 str(dict) 输出字典可打印的字符串表示。 4 type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。 Python字典包含了以下内置方法： 序号 函数及描述 1 dict.clear() 删除字典内所有元素 2 dict.copy() 返回一个字典的浅复制 3 dict.fromkeys(seq[, val]) 创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值 4 dict.get(key, default=None) 返回指定键的值，如果值不在字典中返回default值 5 dict.has_key(key) 如果键在字典dict里返回true，否则返回false 6 dict.items() 以列表返回可遍历的(键, 值) 元组数组 7 dict.keys() 以列表返回一个字典所有的键 8 dict.setdefault(key, default=None) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default 9 dict.update(dict2) 把字典dict2的键/值对更新到dict里 10 dict.values() 以列表返回字典中的所有值 11 pop(key[,default]) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 12 popitem() 返回并删除字典中的最后一对键和值。 5. 文件 I/O1. input()与raw_input()1、在 Python2.x 中 raw_input( ) 和 input( )，两个函数都存在，其中区别为: raw_input( ) 将所有输入作为字符串看待，返回字符串类型。 input( ) 只能接收”数字”的输入，在对待纯数字输入时具有自己的特性，它返回所输入的数字的类型（ int, float ）。 2、在 Python3.x 中 raw_input( ) 和 input( ) 进行了整合，去除了 raw_input( )，仅保留了 input( ) 函数，其接收任意任性输入，将所有输入默认为字符串处理，并返回字符串类型。 当需要输入数值时，需要将输入的变量进行int()操作,进行变量类型转换。 在string类型下，‘+’操作为拼接两个字符串 a = input(&quot;input numbers: \\n&quot;) a = int(a) 2. 保存变量 pickleimport pickle # 存储变量的文件的名字 filename = &#39;shoplist.data&#39; # 初始化变量 shoplist = [&#39;apple&#39;, &#39;mango&#39;, &#39;carrot&#39;] # 以二进制写模式打开目标文件 f = open(filename, &#39;wb&#39;) # 将变量存储到目标文件中区 pickle.dump(shoplist, f) # 关闭文件 f.close() # 删除变量 del shoplist # 以二进制读模式打开目标文件 f = open(filename, &#39;rb&#39;) # 将文件中的变量加载到当前工作区 storedlist = pickle.load(f) print(storedlist) 3. 打开和关闭文件现在，您已经可以向标准输入和输出进行读写。现在，来看看怎么读写实际的数据文件。 Python 提供了必要的函数和方法进行默认情况下的文件基本操作。你可以用 file 对象做大部分的文件操作。 open 函数你必须先用Python内置的open()函数打开一个文件，创建一个file对象，相关的方法才可以调用它进行读写。 语法： file object = open(file_name [, access_mode][, buffering]) 各个参数的细节如下： file_name：file_name变量是一个包含了你要访问的文件名称的字符串值。 access_mode：access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。 buffering:如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。 不同模式打开文件的完全列表： 模式 描述 t 文本模式 (默认)。 x 写模式，新建一个文件，如果该文件已存在则会报错。 b 二进制模式。 + 打开一个文件进行更新(可读可写)。 U 通用换行模式（不推荐）。 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 模式 r r+ w w+ a a+ 读 + + + + 写 + + + + + 创建 + + + + 覆盖 + + 指针在开始 + + + + 指针在结尾 + + File对象的属性一个文件被打开后，你有一个file对象，你可以得到有关该文件的各种信息。 以下是和file对象相关的所有属性的列表： 属性 描述 file.closed 返回true如果文件已被关闭，否则返回false。 file.mode 返回被打开文件的访问模式。 file.name 返回文件的名称。 file.softspace 如果用print输出后，必须跟一个空格符，则返回false。否则返回true。 write()方法write()方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。 write()方法不会在字符串的结尾添加换行符(‘\\n’)： 语法： fileObject.write(string) 在这里，被传递的参数是要写入到已打开文件的内容。 例子： #!/usr/bin/python # -*- coding: UTF-8 -*- # 打开一个文件 fo = open(&quot;foo.txt&quot;, &quot;w&quot;) fo.write( &quot;www.runoob.com!\\nVery good site!\\n&quot;) # 关闭打开的文件 fo.close() 4. 写入txt 数据写数据有几种不同的模式，最常用的是w’, ‘a’, 分别表示擦除原有数据再写入和将数据写到原数据之后： filename = &#39;write_data.txt&#39; with open(filename,&#39;w&#39;) as f: # 如果filename不存在会自动创建， &#39;w&#39;表示写数据，写之前会清空文件中的原有数据！ f.write(&quot;I am Meringue.\\n&quot;) f.write(&quot;I am now studying in NJTECH.\\n&quot;) f.write(str(i) + &quot;d&quot; + &quot; &quot;+&quot;\\n&quot;) 6.assert 断言Python assert（断言）用于判断一个表达式，在表达式条件为 false 的时候触发异常。 断言可以在条件不满足程序运行的情况下直接返回错误，而不必等待程序运行后出现崩溃的情况，例如我们的代码只能在 Linux 系统下运行，可以先判断当前系统是否符合条件。 import sys assert (&#39;linux&#39; in sys.platform), &quot;该代码只能在 Linux 下执行&quot; assert 1==2, &#39;1 不等于 2&#39; Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; AssertionError: 1 不等于 2 assert 后面也可以紧跟参数: assert expression [, arguments] 等价于： if not expression: raise AssertionError(arguments) 7.卷积(1)定义 设:f(x),g(x)是R1上的两个可积函数，作积分：$$\\int ^{+\\infty} _{-\\infty} f(\\tau) g(x-\\tau)d\\tau=f(x)*g(x)$$ 可以证明，关于几乎所有的实数x，上述积分是存在的。这样，随着x的不同取值，这个积分就定义了一个新函数h(x)，称为函数f与g的卷积，记为h(x)=(f\\g)(x)*。 在离散情况下，有$$y(n)=\\sum _{i=-\\infty} ^{\\infty}x(i)h(n-i)=x(n)h(n)$$其中星号表示卷积。当时序n=0时，序列h(-i)是h(i)的时序i取反的结果；时序取反使得h(i)以纵轴为中心翻转180度，所以这种相乘后求和的计算法称为卷积和，简称卷积。另外，n是使h(-i)位移的量，不同的n对应不同的卷积结果。 知乎上在信号系统中的某种理解： 一个函数（如：单位响应）在另一个函数（如：输入信号）上的加权叠加。 重复一遍，这就是卷积的意义：加权叠加。 对于线性时不变系统，如果知道该系统的单位响应，那么将单位响应和输入信号求卷积，就相当于把输入信号的各个时间点的单位响应 加权叠加，就直接得到了输出信号。 书上先反褶再平移，把输入信号当作一个整体，一次算出一个时间点的响应值；而楼主把信号拆开，一次算出一个信号在所有时间的响应值，再把各个信号相加。两者本质上是相同的。 理解一： 先将输入信号180°翻转，时间变为负值，再由 n 作为对应的每个时刻的时间点，每次将翻转后的信号右移1个单位，此时与输入信号与系统x(i)所有重叠部分相乘后求和的结果，即为该时间点的响应值，直至移动 n 个时刻为止，形成响应序列 y(n)。 理解二： 将输入信号序列拆开，分别计算每个时间点的信号在系统中对应的响应序列，将输入序列各个时间点产生的的响应序列叠加求和，即得到整个输入信号的综合响应，最终得到输入信号的响应序列。 (2)numpy中的卷积卷积的概念还可以推广到数列、测度以及广义函数上去。 numpy.convolve(a, v, mode=‘full’)，这是numpy函数中的卷积函数库 参数： a:(N,)输入的一维数组 b:(M,)输入的第二个一维数组 mode:{‘full’, ‘valid’, ‘same’}参数可选 ‘full’ 默认值，返回每一个卷积值，长度是N+M-1,在卷积的边缘处，信号不重叠，存在边际效应。 ‘same’ 返回的数组长度为max(M, N),边际效应依旧存在。 ‘valid’ 返回的数组长度为max(M,N)-min(M,N)+1,此时返回的是完全重叠的点。边缘的点无效。 import matplotlib.pyplot as plt import numpy as np plt.plot([1,2,3,4]) plt.plot([1,1,3]) # 倒过来成为卷积核，然后在上述的数组中滑动，得到结果 end_1=np.convolve([1,2,3,4],[1,1,3],&#39;full&#39;) end_2=np.convolve([1,2,3,4],[1,1,3],&#39;same&#39;) end_3=np.convolve([1,2,3,4],[1,1,3],&#39;valid&#39;) plt.plot(end_1) print(end_1) print(end_2) print(end_3) plt.show() ’full‘ 结果 [ 1 3 8 13 13 12] ’same‘结果[ 3 8 13 13] ’valid‘结果[ 8 13] 8.yield 函数返回def foo(): print(&quot;starting...&quot;) while True: res = yield 4 print(&quot;res:&quot;,res) g = foo() print(&#39;waiting next function&#39;) print(&quot;*&quot;*20) print(next(g)) print(&quot;*&quot;*20) print(next(g)) print(&quot;*&quot;*20) print(next(g)) waiting next function ******************** starting... 4 ******************** res: None 4 ******************** res: None 4 1.程序开始执行以后，因为foo函数中有yield关键字，所以foo函数并不会真的执行，而是先得到一个生成器g(相当于一个对象) 2.直到调用next方法，foo函数正式开始执行，先执行foo函数中的print方法，然后进入while循环 3.程序遇到yield关键字，然后把yield想想成return,return了一个4之后，程序停止，并没有执行赋值给res操作，此时next(g)语句执行完成，所以输出的前两行（第一个是while上面的print的结果,第二个是return出的结果）是执行print(next(g))的结果， 4.程序执行print(““20)，输出20个* 5.又开始执行下面的print(next(g)),这个时候和上面那个差不多，不过不同的是，这个时候是从刚才那个next程序停止的地方开始执行的，也就是要执行res的赋值操作，这时候要注意，这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），所以这个时候res赋值是None,所以接着下面的输出就是res:None, 6.程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，print函数输出的4就是这次return出的4. 带yield的函数是一个生成器，而不是一个函数了，这个生成器有一个函数就是next函数，next就相当于“下一步”生成哪个数，这一次的next开始的地方是接着上一次的next停止的地方执行的，所以调用next的时候，生成器并不会从foo函数的开始执行，只是接着上一步停止的地方开始，然后遇到yield后，return出要生成的数，此步就结束 def foo(): print(&quot;starting...&quot;) while True: res = yield 4 print(&quot;res:&quot;,res) g = foo() print(next(g)) print(&quot;*&quot;*20) print(g.send(7)) starting... 4 ******************** res: 7 4 send是发送一个参数给res的，因为上面讲到，return的时候，并没有把4赋值给res，下次执行的时候只好继续执行赋值操作，只好赋值为None了，而如果用send的话，开始执行的时候，先接着上一次（return 4之后）执行，先把7赋值给了res,然后执行next的作用，遇见下一回的yield，return出结果后结束。 5.程序执行g.send(7)，程序会从yield关键字那一行继续向下运行，send会把7这个值赋值给res变量 6.由于send方法中包含next()方法，所以程序会继续向下运行执行print方法，然后再次进入while循环 7.程序执行再次遇到yield关键字，yield会返回后面的值后，程序再次暂停，直到再次调用next方法或send方法。 9.jupyter notebook1) Jupyter notebook 中的nbagg提供了交互式图像的操作，能够实现图片的放大与缩小操作 %matplotlib nbagg 2)Linux下，nohup 命令 ,不挂断地运行命令。可以将terminal中的log导出，不在terminal中显示。 nohup jupyter notebook &amp; #退出时，使用 # $ exit 10. 一些常用库（1）argparse库命令行解析模块，使用步骤： ​ 1：import argparse ​ 2：parser = argparse.ArgumentParser() 参数： prog：程序的名字 usage：默认情况下，ArgumentParser依据它包含的参数计算出帮助信息 description：这个参数给出程序做什么以及如何工作的简短描述 epilog：显示额外的关于程序的描述 parents：有时候，几个解析器会共享一个共同的参数集。可以使用一个带有所有共享参数的解析器传递给ArgumentParser的parents=参数，而不用重复定义这些参数 formatter_class：ArgumentParser对象允许通过指定一个格式化类来定制帮助信息的格式（argparse.RawDescriptionHelpFormatter、argparse.RawTextHelpFormatter、argparse.ArgumentDefaultsHelpFormatter、argparse.MetavarTypeHelpFormatter） prefix_chars：修改前缀符 fromfile_prefix_chars：以任意一个给定字符开始的参数将被当做文件，并且将被这些文件包含的参数替换 argument_default：指定一个解析器范围的参数默认值 allow_abbrev：允许使用缩写（默认） conflict_handler：关于设置同一个选项具有两个动作 add_help ​ 3：parser.add_argument() 参数 name or flags：传递给add_argument() 的第一个参数因此必须是一个标记序列或者一个简单的参数名字 action：指出应该如何处理命令行参数（支持的操作：’store’ ，’store_const’，’store_true’，’store_false’，’append’，’append_const’，’count’，’help’，’version’） nargs：将一个动作与不同数目的命令行参数关联在一起（支持的值：N,’?’,’*’,’+’） const：用于保存常量值，它们不是从命令行读入但是是ArgumentParser 的动作所要求的 default：其默认值为None，指出如果命令行参数没有出现时它们应该是什么值 type：允许任意必要的类型检查并作类型转换 choices：某些命令行参数应该从一个受限的集合中选择 required：如果要使得选项是必需的，可以指定True作为required=关键字参数的值给add_argument() help：包含参数简短描述的字符串 metavar：默认情况下，对于位置参数直接使用dest的值，对于可选参数则将dest的值变为大写。注意metavar只会改变显示出来的名字parse_args() 对象中属性的名字仍然由dest的值决定。 dest：对于位置参数的动作，dest 通常作为第一个参数提供给add_argument()，对于可选参数的动作，dest的动作通常从选项字符串推导出来，如：ArgumentParser生成的dest的值是将第一个长的选项字符串前面的–字符串去掉。如果没有提供长选项字符串，dest的获得则是将第一个短选项字符串前面的-字符去掉。任何内部的-将被转换为字符以确保字符串是合法的属性名字。（即对于可选参数，先找长的选项字符串，再找短选项字符串，并且内部的-会被转换为字符。） ​ 4：parser.parse_args() 解释：首先导入该模块；创建一个解析对象；向该对象中添加你要关注的命令行参数和选项，每一个add_argument方法对应一个你要关注的参数或选项；最后调用parse_args()方法进行解析； add_argument(name or flags…[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest]) 其中： name or flags：命令行参数名或者选项，如上面的address或者-p,–port.其中命令行参数如果没给定，且没有设置defualt，则出错。但是如果是选项的话，则设置为None nargs：命令行参数的个数，一般使用通配符表示，其中，’?’表示只用一个，’*’表示0到多个，’+’表示至少一个 default：默认值 type：参数的类型，默认是字符串string类型，还有float、int等类型 help：和ArgumentParser方法中的参数作用相似，出现的场合也一致 --help参数可简写成-h,是唯一预设的(不需要指定)。 例子： import argparse parser = argparse.ArgumentParser() parser.add_argument(&quot;echo&quot;) args = parser.parse_args() print args.echo 方法parse_args()通过分析指定的参数返回一些数据，如本例中的echo。 像魔法一样，argparse自动生成这些变量，你可能已经注意到变量echo和我们指定的参数相同。 如果不指定参数类型，argparse默认它是字符串。因此我们需要告诉argparse该参数的整型。 ”-xxx” 可选参数。这个参数事实上是可选的，不指定它也不会出错。如果不指定可选的参数，对应的变量就被设置为None 其他命令见官方文档 ： https://docs.python.org/3/library/argparse.html#prog （2）wget库下载链接 python -m wget [options] options: -o –output FILE|DIR output filename or directory import wget url=&quot;http://www.da.ga.gasg.gsa.&quot; file_path=&quot;./&quot; #可以指定下载文件的路径和名称，默认不更改文件名 wget.download(url, file_path) （3）hashlib 库 摘要算法库，包括MD5，SHA1等等 。 摘要算法又称哈希算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。 通过摘要函数f（）对任意长度的数据data计算出固定长度的摘要digest，目的是为了发现原始数据是否被人篡改过。 因为摘要函数是一个单向函数，计算f（data）很容易，但通过digest反推却非常困难。而且，对原始数据做一个bit的修改，都会导致计算的摘要完全不同。 我们以常见的摘要算法MD5为例，计算处一个字符串的MD5值： import hashlib md5=hashlib.md5() md5.update(&#39;how to use md5 in python hashlib?&#39;.encode(&#39;utf-8&#39;)) print(md5.hexdigest()) 计算结果如下： d26a53750bc40b38b65a520292f69306 如果数据量很大，可以分块多次调用update（），最后计算的结果是一样的. MD5是常见的摘要算法，速度很快，生成结果是固定的128bit字节，通常用一个32位的16进制字符串表示。 另一种常见的摘要算法是SHA1，调用SHA1和调用MD5完全类似. SHA1的结果是160bit字节，通常用一个40位的16进制字符串表示。 比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法不仅越慢，而且摘要长度更长。 摘要算法应用 摘要算法能应用到什么地方？举个常用例子： 任何允许用户登录的网站都会存储用户登录的用户名和口令。如何存储用户名和口令呢？方法是存到数据库表中. 如果以明文保存用户口令，如果数据库泄露，所有用户的口令就落入黑客的手里。此外，网站运维人员是可以访问数据库的，也就是能获取到所有用户的口令。 正确保存口令的方式是不存储用户的明文口令，而是存储用户口令的摘要，比如MD5. 当用户登录时，首先计算用户输入的明文口令的MD5，然后和数据库存储的MD5对比，如果一致，说明口令输入正确，如果不一致，口令肯定错误。 存储MD5的好处是即使运维人员能访问数据库，也无法获知用户的明文口令。 对于常用口令的MD5值很容易被计算出来，所以，要确保存储的用户口令不是那些已经被计算出来的常用口令的MD5，这一方法通过对原始口令加一个复杂字符串来实现，俗称”加盐“. 要注意摘要算法不是加密算法，不能用于加密（因为无法通过摘要反推明文），只能用于防篡改，但是它的单向计算特性决定了可以在不存储明文口令的情况下验证用户口令。 （4）datetime 库1、获取当前时间： print datetime.datetime.now() 2、获取当前日期 print datetime.datetime.now().date() 3、获取当前时间tuple datetime.datetime.now().timetuple() 4、时间移动（几天、几小时前后…） 使用datetime.timedelta这个方法来前后移动时间，可用的参数有weeks，days，hours，minutes，seconds，microseconds等。 print datetime.datetime.now() + datetime.timedelta(days=1) 5、获取两个时间的时间差(now是本地时间，可以认为是你电脑现在的时间；utcnow是世界时间&lt;时区不同，所以这两个时间也是有所不同&gt;) 6、时间格式转化 datetime转str格式： datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) #其中，&#39;-，：&#39;等字符可以自由替换 str格式转datetime格式： print datetime.datetime.strptime(&quot;2018-06-18 16:58:46&quot;,&quot;%Y-%m-%d %H:%M:%S&quot;) #需要将%Y,%m等，分别替换掉前一个式子中的相应数字，其他符号不变，最终输出如上所示的默认格式 7、date.isocalendar() #返回结果是三元组(年号，第几周，第几天) print(&#39;isocalendar():&#39;, datetime.datetime.now().isocalendar()) 8、date.strftime(“%j”) #计算输入的日期是一年中的第几天 days=int(input_date.strftime(&quot;%j&quot;)) （5）tqdm 进度模块 Tqdm 是一个快速，可扩展的Python进度条，可以在 Python 长循环中添加一个进度提示信息，用户只需要封装任意的迭代器 tqdm(iterator)。 import time from tqdm import tqdm from tqdm._tqdm import trange for i in tqdm(range(100)): time.sleep(0.01) alist = list(&#39;letters&#39;) bar = tqdm(alist) for letter in bar: bar.set_description(f&quot;Now get {letter}&quot;) 11.字符串中引用变量（1）+ 连字符 name = &#39;zhangsan&#39; print(&#39;my name is &#39;+name) \\#结果为 my name is zhangsan （2）% 字符name = &#39;zhangsan&#39; age = 25 price = 4500.225 print(&#39;my name is %s&#39;%(name)) print(&#39;i am %d&#39;%(age)+&#39; years old&#39;) print(&#39;my price is %f&#39;%(price)) \\# 保留指定位数小数(四舍五入) print(&#39;my price is %.2f&#39;%(price)) 结果为my name is zhangsani am 25 years oldmy price is 4500.225000my price is 4500.23 （3）format()函数对于变量较多的情况，加入加’+’或者’%’相对比较麻烦，这种情况下可以使用format函数 name = &#39;zhangsan&#39; age = 25 price = 4500.225 info = &#39;my name is {my_name},i am {my_age} years old,my price is {my_price}&#39;\\ .format(my_name=name,my_age=age,my_price=price) print(info) 结果为： # my name is zhangsan,i am 25 years old,my price is 4500.225 12. *args 和 **kwargs *和**主要用在参数定义和参数传递的时候。对于参数传递来说，*和**都是用来解包的，对于参数定义的时候，*和**都是用来打包的。两者应用在对于参数个数不确定的情况下。*主要是用来对tuple型参数打包或解包，对应的是函数的位置参数。而**kwargs则是主要用来对dict型参数，对应的是函数的关键字参数 (1)在定义函数当中 def fun_var_args(farg, *args): print &quot;arg:&quot;, farg for value in args: print &quot;another arg:&quot;, value fun_var_args(1, &quot;two&quot;, 3) # *args可以当作可容纳多个变量组成的list def fun_var_kwargs(farg, **kwargs): print &quot;arg:&quot;, farg for key in kwargs: print &quot;another keyword arg: %s: %s&quot; % (key, kwargs[key]) fun_var_kwargs(farg=1, myarg2=&quot;two&quot;, myarg3=3) # myarg2和myarg3被视为key， #**kwargs可以当作容纳多个key和value的字典 RESULT: arg: 1 another arg: two another arg: 3 arg: 1 another keyword arg: myarg2: two another keyword arg: myarg3: 3 (2)在函数使用中args = [&quot;two&quot;, 3] #list fun_var_args_call(1, *args) kwargs = {&quot;arg3&quot;: 3, &quot;arg2&quot;: &quot;two&quot;} # dictionary fun_var_args_call(1, **kwargs) RESULT: arg1: 1 arg2: two arg3: 3 arg1: 1 arg2:&quot;two&quot; arg3:3 13.OS 库os.mkdiros.mkdir() 方法用于以数字权限模式创建目录。默认的模式为 0777 (八进制)。 语法: mkdir()方法语法格式如下： os.mkdir(path[, mode]) 参数 path – 要创建的目录 mode – 要为目录设置的权限数字模式 linux系统文件夹644、755、777权限设置详解 ，左至右， 第一位数字代表文件所有者的权限， 第二位数字代表同组用户的权限， 第三位数字代表其他用户的权限。 而具体的权限是由数字来表示的，读取的权限等于4，用r表示；写入的权限等于2，用w表示；执行的权限等于1，用x表示； 通过4、2、1的组合，得到以下几种权限：0（没有权限）；4（读取权限）；5（4+1 | 读取+执行）；6（4+2 | 读取+写入）；7（4+2+1 | 读取+写入+执行） 该方法没有返回值。 os.listdir()用于返回一个由文件名和目录名组成的列表， 需要注意的是它接收的参数需要是一个绝对的路径 例如： 已知路径path = r’C:\\Users\\zhang-bai\\Desktop’ 请输出该路径下的所有文件和目录名称 import os path = r&#39;C:\\Users\\zhang-bai\\Desktop&#39; #不加r会报错 #:(unicode error) ‘unicodeescape’ codec can’t decode bytes in position 2-3: truncated \\UXXXXXXXX escape #在Python中\\是转义符，\\u表示其后是UNICODE编码，因此\\User在这里会报错，在字符串前面加个r表示就可以了 for i in os.listdir(path): print(i) os.path.isdir()用于判断对象是否为一个目录，返回 True / False 例如： import os path = r&#39;C:\\Users&#39; os.path.isdir(path) os.path.isfile()用于判断对象是否为一个文件 例如： 已知路径path = /home/python/Desktop/ 请输出该目录下包含的文件名称 import os path = r&#39;C:\\Users\\zhang-bai\\Desktop&#39; for i in os.listdir(path): if os.path.isfile(i): print(i,&#39;\\n \\n&#39;) print(i) os.path.join()连接两个或更多的路径名组件 1.如果各组件名首字母不包含’/’，则函数会自动加上 2.如果有一个组件是一个绝对路径，则在它之前的所有组件均会被舍弃 3.如果最后一个组件为空，则生成的路径以一个’/’分隔符结尾 configs_EN = &quot;AE-MSEloss_batch{}_epoch{}_RMSprop_scheduler-step{}-gamma{}_lr{}_EN&quot;.format(BATCH_SIZE, EPOCH, STEP_SIZE, GAMMA, LR) model_dir = &quot;models&quot; model_path_EN = os.path.join(model_dir,configs_EN) os_root_dirroot_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) train_file = os.path.join(root_dir,&quot;train.csv&quot;) 14.迭代 iternext() 返回迭代器的下一个项目。 next 语法： next(iterator[, default]) 参数说明： iterator – 可迭代对象 default – 可选，用于设置在没有下一个元素时返回该默认值，如果不设置，又没有下一个元素则会触发 StopIteration 异常。 返回对象帮助信息。 #!/usr/bin/python # -*- coding: UTF-8 -*- # 首先获得Iterator对象: it = iter([1, 2, 3, 4, 5]) # 循环: while True: try: # 获得下一个值: x = next(it) print(x) except StopIteration: # 遇到StopIteration就退出循环 break 15.创建空列表、字典创建空列表： a=list() / a=[] 创建空元组：tuple = () / a=() 创建单个元素的元组：tuple_single = (‘1’,) 创建空字典： dict = () / a={} 创建空集合：a = set() 集合（set）是一个无序的不重复元素序列。 可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。 创建格式： parame = {value01,value02,...} 或者 set(value) 其中，value值为一个字符串，set将字符串每个字符都当作一个元素存储 如：a=set(‘abcab’) 则 a = {‘a’, ‘b’, ‘c’} 16.python 切片1.负号问题 x[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] x[-3:] # [8, 9, 10] x[:-3] # [1, 2, 3, 4, 5, 6, 7] 负数在左侧，则从后往前数n个 负数在右侧，则是排除了后n个 2.冒号问题 a = [0,1,2,3,4,5,6,7,8,9]b = a[i:j] 表示复制a[i]到a[j-1]，以生成新的list对象b = a[1:3] 那么，b的内容是 [1,2]当i缺省时，默认为0，即 a[:3]相当于 a[0:3]当j缺省时，默认为len(alist), 即a[1:]相当于a[1:10]当i,j都缺省时，a[:]就相当于完整复制一份a了 b = a[i:j:s]这种格式 i,j与上面的一样，但s表示步进，缺省为1.所以a[i:j:1]相当于a[i:j]当s&lt;0时，i缺省时，默认为-1. j缺省时，默认为-len(a)-1所以a[::-1]相当于 a[-1:-len(a)-1:-1]，也就是从最后一个元素到第一个元素复制一遍","categories":[{"name":"Fun","slug":"Fun","permalink":"/categories/Fun/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}],"keywords":[{"name":"Fun","slug":"Fun","permalink":"/categories/Fun/"}]},{"title":"Fortran 教程","slug":"Fortran-教程","date":"2020-02-04T07:00:25.246Z","updated":"2020-02-04T13:02:46.387Z","comments":true,"path":"2020/02/04/Fortran-教程/","link":"","permalink":"/2020/02/04/Fortran-教程/","excerpt":"","text":"一、基础知识 ​ Fortran 不区分大小写","categories":[{"name":"Fun","slug":"Fun","permalink":"/categories/Fun/"}],"tags":[],"keywords":[{"name":"Fun","slug":"Fun","permalink":"/categories/Fun/"}]},{"title":"filters","slug":"filters","date":"2020-02-04T07:00:25.244Z","updated":"2020-02-04T13:02:33.203Z","comments":true,"path":"2020/02/04/filters/","link":"","permalink":"/2020/02/04/filters/","excerpt":"","text":"滤波器[TOC] 一、FFT对应的频率和相位 一个模拟信号，经过ADC采样之后，就变成了数字信号。采样定理告诉我们，采样频率要大于信号频率的两倍 N个采样点，经过FFT之后，就可以得到N个点的FFT结果。为了方便进行FFT运算，通常N取2的整数次方。 假设采样频率为Fs，信号频率F，采样点数为N。那么FFT之后结果就是一个为N点的复数。每一个点就对应着一个频率点。这个点的模值，就是该频率值下的幅度特性。 假设原始信号的峰值为A，那么FFT的结果的每个点（除了第一个点直流分量之外）的模值就是A的N/2倍。而第一个点就是直流分量，它的模值就是直流分量的N倍。而每个点的相位，就是在该频率下的信号的相位。 第一个点表示直流分量（即0 Hz），而最后一个点N的再下一个点（实际上这个点是不存在的，这里是假设的第N+1个点，也可以看做是将第一个点分做两半分，另一半移到最后）则表示采样频率Fs，这中间被N-1个点平均分成N等份，每个点的频率依次增加。例如某点n所表示的频率为：$$f(n) = (n-1) \\frac{Fs}{N}$$由上面的公式可以看出，Fn所能分辨到频率为Fs/N，如果采样频率Fs为1024 Hz，采样点数N为1024点，则可以分辨到1 Hz。1024 Hz的采样率采样1024点，刚好是1秒，也就是说，采样1秒时间的信号并做FFT，则结果可以分析到1 Hz，如果采样2秒时间的信号并做FFT，则结果可以分析到0.5 Hz。如果要提高频率分辨力，则必须增加采样点数，也即采样时间。频率分辨率和采样时间是倒数关系。 假设FFT之后某点n用复数a+bi表示，那么这个复数的模就是$$A(n) = \\sqrt{ a^2+b^2}$$相位就是$$\\varphi(n)=atan2(b,a)\\\\$$ 其中atan2(b,a)是求坐标为(a,b)点的角度值，范围从-pi到pi 对于n=1点的信号，是直流分量，幅度即为 A/N。由于FFT结果的对称性，通常我们只使用前半部分的结果，即小于采样频率一半的结果。 t=0:1/256:1;%采样步长 y= 2+3*cos(2*pi*50*t-pi*30/180)+1.5*cos(2*pi*75*t+pi*90/180); N=length(t); %样点个数 plot(t,y); fs=256;%采样频率 df=fs/(N-1) ;%分辨率 f=(0:N-1)*df;%其中每点的频率 Y=fft(y)/N*2;%真实的幅值 %Y=fftshift(Y); figure(2) plot(f,abs(Y)); %只使用前半部分 %figure(2) %plot(f(1:N/2),abs(Y(1:N/2))); 二、雷克子波实验clc,clear fm=10;%主频 dt=0.001;%时间域采样间隔 number=1000%采样点数 % t=-number/2+1:number/2; t=1/number:2/number:1; a=(1-2*(pi*fm*t).^2).*exp(-(pi*fm*t).^2); figure subplot(2,1,1); plot(t,a); title(&#39;Ricker-雷克子波&#39;); xlabel(&#39;时间t（s）&#39;); ylabel(&#39;幅值A&#39;); for i=1:length(t) f(i)=1/dt/number*(i-1);%计算频率 end Y=abs(fft(a));%fourier变换，取振幅谱 subplot(2,1,2) % plot(t,Y) plot(f(1:length(t)/2),Y(1:length(t)/2)); title(&#39;Ricker子波的振幅谱&#39;); xlabel(&#39;频率f（hz）&#39;); ylabel(&#39;振幅谱&#39;); %注：时间域采样间隔为0.001s，采样点数为100点，总的时间长度为0.1s，则频率域采样间隔为10hz。 %% noise = 0.2*cos(2*pi*200*t + pi*45/180); %频率给定180 figure for i = 1:length(t) f_noise(i) = (i-1)*1/dt/number; end subplot(2,1,1) Y_noise = abs(fft(noise)); plot(f_noise(1:length(t)/2),Y_noise(1:length(t)/2)) subplot(212) plot(t,noise) %% b = a + noise ; Y_b = abs(fft(b)); for i = 1:length(t) f_b (i ) = (i-1) * (1/dt)/number; end figure subplot(211) plot(t,b) subplot(212) plot(f_b(1:length(t)/2),Y_b(1:length(t)/2)) %% fc = 10; % t=1/number:2/number:2; h = sin(2*pi*fc.*t)./(pi.*t) ; Y_cc = conv(b,h) ; Y_c = Y_cc(250:749); Y_d = abs(fft(Y_c)) ; for i = 1:length(Y_d) f_c(i) = (i-1)*(1/dt)/number; end figure subplot(223) plot( Y_cc) title(&#39;conv&#39;) subplot(221) plot(t,b) title(&#39;b&#39;) subplot(224) plot(f_c(1:length(t)/2),Y_d(1:length(t)/2)) title(&#39;frequence filter&#39;) subplot(222) plot(f_b(1:length(t)/2),Y_b(1:length(t)/2)) title(&#39;frequence noise&#39;) 代码2： clc,clear % low_pass N = 256 ; %采样点数 Fs = 1024; %时域采样频率1024Hz dt = 1/Fs; %采样间隔 t = dt:dt:dt*N; fm = 30 ; a=(1-2*(pi*fm*t).^2).*exp(-(pi*fm*t).^2); for i = 1:N f_rick(i) = (i-1)*Fs/N ; end Y1 = abs(fft(a))/N*2 ; for fn = [80,150] %噪声频率 Hz t2 = -dt*N/2 +dt:dt:dt*N/2 ; % noise = 0.03 + 0.02*sin(2*pi*fn*t2); noise = 0.4*sin(2*pi*fn*t2); Y2 = abs(fft(noise))/N*2 ; a_n = a + noise; Y3 = abs(fft(a_n))/N*2; for fc = [50,100] %低通滤波器阈值 low_pass = sin(2*pi*fc*(t2))./(pi*(t2)) ; for i = 1:N if (t2(i) == 0) low_pass(i) = 2*fc; break; end end Y4 = abs(fft(low_pass))/N*2; deal = conv(a_n,low_pass) ; Y5 = abs(fft(deal))/length(deal)*2; for i = 1:length(deal) f_deal(i) = (i-1)*Fs/length(deal); end %% figure subplot(521) plot(t,a) title(&#39;ricker 时间域&#39;) subplot(522) plot(f_rick(1:N/2),Y1(1:N/2)) title(&#39;ricker 频率域&#39;) subplot(523) plot(t2,noise) title([&#39;noise&#39;, num2str(fn),&#39; Hz 时间域&#39;]) subplot(524) plot(f_rick(1:N/2),Y2(1:N/2)) title([&#39;noise&#39;, num2str(fn),&#39; Hz 频率域&#39;]) subplot(525) plot(t,a_n) title(&#39;combine 时间域&#39;) subplot(526) plot(f_rick(1:N/2),Y3(1:N/2)) title(&#39;combine 频率域&#39;) subplot(527) plot(t2,low_pass) title(&#39;低通滤波器 时间域&#39;) subplot(528) plot(f_rick(1:N/2),Y4(1:N/2)) title(&#39;低通滤波器 频率域&#39;) subplot(529) plot(deal) title([&#39;低通滤波&#39;, num2str(fc),&#39; Hz 时间域&#39;]) subplot(5,2,10) plot(f_deal(1:N),Y5(1:N)) title([&#39;低通滤波&#39;, num2str(fc),&#39; Hz 频率域&#39;]) end end 结果图： 问题： 1.卷积后，时间域信号如何变化 Answer： 2.吉普斯现象 Answer： 3.伪门效应 Answer ： 暂未出现","categories":[{"name":"Geophysics","slug":"Geophysics","permalink":"/categories/Geophysics/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}],"keywords":[{"name":"Geophysics","slug":"Geophysics","permalink":"/categories/Geophysics/"}]},{"title":"Conda基本语法","slug":"conda基本使用方法","date":"2020-02-04T07:00:25.241Z","updated":"2020-02-04T13:11:20.336Z","comments":true,"path":"2020/02/04/conda基本使用方法/","link":"","permalink":"/2020/02/04/conda基本使用方法/","excerpt":"","text":"conda基本使用方法conda 是一款开源跨平台的环境管理和包管理软件。conda由Python编写，但不局限于Python，支持绝大数流行编程语言。conda完美契合机器学习，能方便安装各种框架和部署生产环境。 conda 清华镜像网站下载MiniConda，根据系统下载安装即可，同时添加conda到系统路径方便使用。 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/ # 设置搜索时显示通道地址 conda config --set show_channel_urls yes 有时候国内镜像源无法连接，需要恢复原来的源： conda config --remove-key channels 查看conda版本conda --version 更新condaconda update conda 环境管理 创建环境conda create --name myenv 或者从environment.yml文件创建conda env create -f environment.yml conda install python=3.8 安装指定版本的python 查看所有环境conda info --envs 或者 conda env list 激活环境 source activate myenv #linux and macOS activate myenv #windows PowerShell 激活环境需要先安装额外库然后更改执行策略conda install -n root -c pscondaenvs pscondaenvs Set-ExecutionPolicy RemoteSigned #管理员打开PS执行 退出环境 source deactivate myenv #linux and macOS deactivate myenv #windows 更新环境 conda update --name myenv 导出环境 conda env export &gt; environment.yml #可以编辑yml文件 删除环境 conda remove --name myenv --all 或者 conda env remove --name myenv 包管理 查找包 conda search pkgname 下载包 conda install pkgname #最新版 conda install pkgname=x.x #指定版本 conda install -c channel pkgname #anaconda.org上的包 channel为发布者的通道 查看包 conda list #查看已激活环境所有包信息 conda list -n myenv pkgname #查看myenv环境中的pkgname包信息 更新包 conda update pkgname 固定包 conda update pkgname --no-pin #pkgname 的版本永远为当前版本，不会被更新 卸载包 conda uninstall pkgname 删除包 conda remove pkgname 不要使用pip安装包，pip和conda不建议混用，推荐使用conda","categories":[{"name":"Fun","slug":"Fun","permalink":"/categories/Fun/"}],"tags":[],"keywords":[{"name":"Fun","slug":"Fun","permalink":"/categories/Fun/"}]},{"title":"bicubic interpolati","slug":"bicubic-interpolati","date":"2020-02-04T06:59:56.633Z","updated":"2020-02-04T13:01:51.276Z","comments":true,"path":"2020/02/04/bicubic-interpolati/","link":"","permalink":"/2020/02/04/bicubic-interpolati/","excerpt":"","text":"源于科学计算课程作业，现将代码整理如下： /*******2019.03.31********** 双三次多项式插值 Bi-cubic interpolation 插值数据大小384*122，网格间距24m*24m 122行，384列。。。。 将数据模型插值为网格间距为dx=4m，dz=6m的数据模型。 数据文件名为md.txt ***************************/ #include&lt;cstdio&gt; #include&lt;canshu.h&gt; //参数及常量定义 const int M=122,N=384; //原始数据大小 const int dX=24,dZ=24,dz=6,dx=4; //原始和插入后的网格间距 const int m=dZ/dz*(M-1)+1,n=dX/dx*(N-1)+1; //插值后网格大小 double indata[M][N]={0.0}; //原始数据 double outdata[m][n]={0.0}; FILE * fpin,*fpout; //两个文件指针，表示输入输出 struct matrix { //定义矩阵结构体 int dx,dy; double **A; matrix() {} matrix (int m ,int n) { //动态申请空间 A=new double *[m]; for(int i=0;i&lt;m;i++) { A[i]=new double [n]; } dx=n; dy=m; } }; matrix operator * (const matrix c1,const matrix c2) { //定义矩阵乘法 matrix temp(c1.dy,c2.dx); double sum=0.0; if(c1.dx != c2.dy ) { // 矩阵不合法 ，退出 printf(&quot;error!\\n矩阵维度不匹配\\n&quot;); return temp; } for(int i=0;i&lt;c1.dy;i++) { for(int u=0;u&lt;c2.dx;u++) { //c2的列 for(int j=0;j&lt;c1.dx;j++) { sum+=1.0*c1.A[i][j]*c2.A[j][u] ; } temp.A[i][u]=sum; sum=0.0; } } return temp; } matrix trans( const matrix c) { //矩阵转置 matrix temp(c.dx,c.dy); for(int i=0;i&lt;c.dy;i++){ for(int j=0;j&lt;c.dx;j++) { temp.A [j][i]=c.A [i][j]; } } return temp; } double Dd[4][4]={{-1,3,-3,1},{3,-6,3,0},{-3,0,3,0},{1,4,1,0}}; matrix D(4,4) ; void calculate( ) { double u,w; // 定义Δλ printf(&quot;\\n正在计算\\n&quot;); for(int j=dZ/dz;j&lt;m-dZ/dz-1;j++) { //行号 w=((j*dz)%dZ)*1.0/(dZ*1.0); //设置矩阵Z matrix Z(1,4); Z.A[0][3]=1.0; for(int k=2;k&gt;=0;k--) { Z.A[0][k]=Z.A[0][k+1]*1.0*w; } for(int i=dX/dx;i&lt;n-dX/dx-1;i++) { // 列 号 u=((i*dx)%dX)*1.0/(dX*1.0); //设置矩阵X matrix X(1,4); X.A[0][3]=1.0; for(int k=2;k&gt;=0;k--) { X.A[0][k]=X.A[0][k+1]*1.0*u; } int xx,yy; //xx,yy为原始数据对应下标 xx=i*dx/dX-1;yy=j*dz/dZ-1; matrix C(4,4); //设置矩阵C for(int ii=0;ii&lt;4;ii++) { //ii为行数 for(int jj=0;jj&lt;4;jj++) { C.A[ii][jj]=indata[yy][xx]; // yy为行号 xx++; } yy++; xx=i*dx/dX-1; } outdata[j][i]=(X*D*C*trans(D)*trans(Z)).A[0][0]/36.0; } } //写入文件 printf(&quot;\\n运算完成，开始写入\\n&quot;); for(int j=dZ/dz;j&lt;m-dZ/dz-1;j++) { //j代表行号 for(int i=dX/dx;i&lt;n-dX/dx-2;i++) { //i代表列号 fprintf(fpout,&quot;%lf &quot;,outdata[j][i]); } fprintf(fpout,&quot;%lf\\n&quot;,outdata[j][n-dX/dx-2]); } } int main() { printf(&quot;**********开始执行*********\\n&quot;); //给D矩阵赋值 for(int i=0;i&lt;4;i++) { for (int j=0;j&lt;4;j++) { D.A[i][j]=Dd[i][j]; } } char *filepath,*filepath1,*filepath2; //打开文件 filepath=&quot;canshu.txt&quot;; fpin=fopen(filepath,&quot;r&quot;); fscanf(fpin,&quot;%s %s&quot;,filepath1,filepath2); fscanf(fpin,&quot;%d %d %d %d&quot;,&amp;dX,&amp;dZ,&amp;dx,&amp;dz); fclose(fpin); fpin=fopen(filepath1,&quot;r&quot;); printf(&quot;\\n开始导入数据\\n&quot;); for(int i=0;i&lt;M;i++) { // 行 for(int j=0;j&lt;N;j++ ) { // 列 fscanf(fpin,&quot;%lf&quot;,&amp;indata[i][j]); } } fclose(fpin); //输入完成 printf(&quot;\\n数据导入成功！\\n&quot;); fpout=fopen(&quot;output.txt&quot;,&quot;w&quot;); calculate(); //计算插值 fclose(fpout); printf(&quot;\\n*********程序运行结束**********&quot;); return 0; } 测试时使用的代码： /***********************2019.04.03*********************** 双三次多项式插值 Bi-cubic interpolation 测试文件 测试函数为： v=c1+c2*z+a1.*sin(2*pi*z./100)+a2.*sin(2*pi*x./100); 其中参数选取为： c1=1800;c2=0.4;a1=0.1;a2=0.5;lm1=100;lm2=100; 为方便起见，取50行，50列数据进行插值 选取原始网格间距dX=dZ=10m，以2m为步长进行插值 输入文件为 ceshi.txt ,输出到文件 outputceshi.txt *********************************************************/ #include&lt;cstdio&gt; //参数及常量定义 const int M=50,N=50; //原始数据大小 const int dX=10,dZ=10,dz=2,dx=2; //原始和插入后的网格间距 const int m=dZ/dz*(M-1)+1,n=dX/dx*(N-1)+1; //插值后网格大小 double indata[M][N]={0.0}; //原始数据 double outdata[m][n]={0.0}; FILE * fpin,*fpout; //两个文件指针，表示输入输出 struct matrix { //定义矩阵结构体 int dx,dy; double **A; matrix() {} matrix (int m ,int n) { //动态申请空间 A=new double *[m]; for(int i=0;i&lt;m;i++) { A[i]=new double [n]; } dx=n; dy=m; } }; matrix operator * (const matrix c1,const matrix c2) { //定义矩阵乘法 matrix temp(c1.dy,c2.dx); double sum=0.0; if(c1.dx != c2.dy ) { // 矩阵不合法 ，退出 printf(&quot;error!\\n矩阵维度不匹配\\n&quot;); return temp; } for(int i=0;i&lt;c1.dy;i++) { for(int u=0;u&lt;c2.dx;u++) { //c2的列 for(int j=0;j&lt;c1.dx;j++) { sum+=1.0*c1.A[i][j]*c2.A[j][u] ; } temp.A[i][u]=sum; sum=0.0; } } return temp; } matrix trans( const matrix c) { //矩阵转置 matrix temp(c.dx,c.dy); for(int i=0;i&lt;c.dy;i++){ for(int j=0;j&lt;c.dx;j++) { temp.A [j][i]=c.A [i][j]; } } return temp; } int Dd[4][4]={{-1,3,-3,1},{3,-6,3,0},{-3,0,3,0},{1,4,1,0}}; matrix D(4,4) ; void calculate( ) { double u,w; // 定义Δλ printf(&quot;\\n正在计算\\n&quot;); for(int j=dZ/dz;j&lt;m-dZ/dz-1;j++) { //行号 w=((j*dz)%dZ)*1.0/(dZ*1.0); //设置矩阵Z matrix Z(1,4); Z.A[0][3]=1.0; for(int k=2;k&gt;=0;k--) { Z.A[0][k]=Z.A[0][k+1]*1.0*w; } for(int i=dX/dx;i&lt;n-dX/dx-1;i++) { // 列 号 u=((i*dx)%dX)*1.0/(dX*1.0); //设置矩阵X matrix X(1,4); X.A[0][3]=1.0; for(int k=2;k&gt;=0;k--) { X.A[0][k]=X.A[0][k+1]*1.0*u; } int xx,yy; //xx,yy为原始数据对应下标 xx=i*dx/dX-1;yy=j*dz/dZ-1; matrix C(4,4); //设置矩阵C for(int ii=0;ii&lt;4;ii++) { //ii为行数 for(int jj=0;jj&lt;4;jj++) { C.A[ii][jj]=indata[yy][xx]; // yy为行号 xx++; } yy++; xx=i*dx/dX-1; } outdata[j][i]=(Z*D*C*trans(D)*trans(X)).A[0][0]/36.0; } } //写入文件 printf(&quot;\\n运算完成，开始写入\\n&quot;); for(int j=dZ/dz;j&lt;m-dZ/dz-1;j++) { //j代表行号 for(int i=dX/dx;i&lt;n-dX/dx-2;i++) { //i代表列号 fprintf(fpout,&quot;%lf &quot;,outdata[j][i]); } fprintf(fpout,&quot;%lf\\n&quot;,outdata[j][n-dX/dx-2]); } printf(&quot;\\n写入完成\\n&quot;); } int main() { printf(&quot;**********开始执行*********\\n&quot;); //给D矩阵赋值 for(int i=0;i&lt;4;i++) { for (int j=0;j&lt;4;j++) { D.A[i][j]=Dd[i][j]*1.0; } } char *filepath; //打开文件 filepath=&quot;ceshi.txt&quot;; fpin=fopen(filepath,&quot;r&quot;); printf(&quot;\\n开始导入数据\\n&quot;); for(int i=0;i&lt;M;i++) { // 行 for(int j=0;j&lt;N;j++ ) { // 列 fscanf(fpin,&quot;%lf&quot;,&amp;indata[i][j]); } } fclose(fpin); //输入完成 printf(&quot;\\n数据导入成功！\\n&quot;); fpout=fopen(&quot;outputceshi.txt&quot;,&quot;w&quot;); calculate(); //计算插值 fclose(fpout); printf(&quot;\\n*********程序运行结束**********&quot;); return 0; }","categories":[{"name":"Geophysics","slug":"Geophysics","permalink":"/categories/Geophysics/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"/tags/c-c/"}],"keywords":[{"name":"Geophysics","slug":"Geophysics","permalink":"/categories/Geophysics/"}]},{"title":"2D wave function","slug":"2D-wave-function","date":"2020-02-04T06:59:56.624Z","updated":"2020-02-04T12:59:59.393Z","comments":true,"path":"2020/02/04/2D-wave-function/","link":"","permalink":"/2020/02/04/2D-wave-function/","excerpt":"","text":"地震波正演程序，采用marmousi模型进行地震波模拟，边界进行了PCL吸收处理。 主函数： %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %二阶空间二阶时间声波方程 %marmousi模型 %占用内存空间优化 %小仙出品，必属精品 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% clc,clear %% 设置初始变量 for q=1 load md.txt dh=10;dk=10;dt=0.001;endt=1.7;N=100; %dh,dk,dt分别为x,z,t的增量，endt为终止时间 fm=15;X=384+N*2;Z=122+N*2; %雷克子波主频15Hz,吸收层厚度为N Sx=X/2;Sz=N+3; %震源位置 u=zeros(Z,X,3); %初始化位移为0 DT=Dt(Sz,Sx,Z,X); %初始化δ函数 [weakx ,weakz]=attnuate(Z,X,N); v1=min(min(md));v2=max(max(md)); %速度模型 % v=[v1*ones(Z/2,X);v1*ones(Z/4,3*X/8) md v1*ones(Z/4,3*X/8);v1*ones(Z/4,X)]; for ll=1:N vll(:,ll)=md(:,1); vrr(:,ll)=md(:,384); vbb(ll,:)=md(122,:); end vbll=v1*ones(N,N);vbrr=v1*ones(N,N); v=[v1*ones(N,X);vll md vrr;vbll vbb vbrr ]; end %% 预判断 for q=0 if ( v2*dt/dh &gt;= 1/sqrt(2) ) errordlg( &#39;ERROR!!! 不满足稳定性条件！当前 Vmax*dt/dh &gt;= 1/sqrt(2)&#39;); return end if ( dh &gt; v1/8/fm ) warndlg(&#39;请减小 x 的步长以减少频散&#39; ); return; end end %% 计算差分方程 [a,b]=meshgrid(dh:dh:dh*(X-2*N),dk:dk:dk*(Z-2*N)); % figure(1) % imagesc(0:dh:dh*(X-2*N),0:dk:dk*(Z-2*N),u(N+1:Z-N,N+1:X-N,1),[-1,1]) % hold on % contour(a,b,md,&#39;k&#39;) % hold on for q=1 k=1; pic_num=1; for number=2:endt/dt for i=2:Z-1 for j=2:X-1 u(i,j,mod(k+2,3)+1)=(dt^2*v(i,j)^2/dh^2*(u(i+1,j,mod(k+1,3)+1)+u(i-1,j,mod(k+1,3)+1)-2*u(i,j,mod(k+1,3)+1))+(2-weakx(i,j)^2*dt^2)*u(i,j,mod(k+1,3)+1)/2+(weakx(i,j)*dt-1)*u(i,j,mod(k,3)+1)/2)/(weakx(i,j)*dt+1)... +(dt^2*v(i,j)^2/dk^2*(u(i,j+1,mod(k+1,3)+1)+u(i,j-1,mod(k+1,3)+1)-2*u(i,j,mod(k+1,3)+1))+(2-weakz(i,j)^2*dt^2)*u(i,j,mod(k+1,3)+1)/2+(weakz(i,j)*dt-1)*u(i,j,mod(k,3)+1)/2)/(weakz(i,j)*dt+1)... +DT(i,j)*ricker(number*dt-dt,fm); end end k=mod(k,3)+1; record(number-1,:)=u(Sz,N+1:X-N,k); if( mod( number, 10) == 0 ) figure(2) imagesc(0:dh:dh*(X-2*N),0:dk:dk*(Z-2*N),u(N+1:Z-N,N+1:X-N,k),[-1,1]); hold on contour(a,b,md,&#39;k&#39;) title(&#39;Marmousi model snapshot&#39;) % h2=colorbar; % set(get(h2,&#39;Title&#39;),&#39;string&#39;,&#39;u &#39;); colormap(jet) pause(0.0001) F=getframe(gcf); I=frame2im(F); [I,map]=rgb2ind(I,256); if pic_num == 1 imwrite(I,map,&#39;Marmousi_model_snapshot_100.gif&#39;,&#39;gif&#39;, &#39;Loopcount&#39;,inf,&#39;DelayTime&#39;,0.001); else imwrite(I,map,&#39;Marmousi_model_snapshot_100.gif&#39;,&#39;gif&#39;,&#39;WriteMode&#39;,&#39;append&#39;,&#39;DelayTime&#39;,0.001); end pic_num = pic_num + 1; end end end %% 绘图 %% ***********************速度model************************** figure(1) for q=1 % figure(1) imagesc(0:dh:dh*(X-2*N),0:dk:dk*(Z-2*N),v(N+1:Z-N,N+1:X-N)) h=colorbar; set(get(h,&#39;Title&#39;),&#39;string&#39;,&#39;v (m/s)&#39;); colormap(jet) end %% ***********************地震记录*************************** figure(3) imagesc(0:dh:dh*(X-2*N),0:round(endt/dt),record) colormap(gray) colorbar xlabel(&#39;X-m&#39;) ylabel(&#39;t-ms&#39;) %% *************************滤波***************************** figure(4) subplot(1,2,1) %速度模型 imagesc(0:dh:dh*(X-2*N),0:dk:dk*(Z-2*N),v(N+1:Z-N,N+1:X-N)) hold on plot(dh*(X-2*N)/2,20,&#39;pr&#39;,&#39;MarkerSize&#39;,13) text(dh*(X-2*N)/2+35,80,&#39;震源&#39;,&#39;FontSize&#39;,15) h=colorbar; set(get(h,&#39;Title&#39;),&#39;string&#39;,&#39;v (m/s)&#39;); colormap(jet) title(&#39;model&#39;) xlabel(&#39;X-m&#39;) ylabel(&#39;Z-m&#39;) subplot(1,2,2) imagesc(0:dh:dh*(X-2*N),0:round(endt/dt),record) colorbar % colormap(gray) xlabel(&#39;X-m&#39;) ylabel(&#39;t-ms&#39;) title(&#39;record&#39;) 衰减函数： function [x,z]=attnuate(Z,X,N) %a 衰减因子 % Z，X 行列数 % N 衰减层数 % 余弦型吸收因子 B=500; x=zeros(Z,X); z=zeros(Z,X); for i=1:Z for j=1:X if( i &lt; N+1 ) pm=i; z(i,j)=B*(1-cos(pi*(N-pm)/2/N)); if (j&lt;N+1) pmx=j; x(i,j)=B*(1-cos(pi*(N-pmx)/2/N)); else if ( j &lt;= X-N) x(i,j)=0; else pmx=X-j; x(i,j)=B*(1-cos(pi*(N-pmx)/2/N)); end end else if( i &lt;= Z-N ) z(i,j)=0; if ( j &lt; N+1 ) pmx=j; x(i,j)=B*(1-cos(pi*(N-pmx)/2/N)); else if( j &lt;= X-N) x(i,j)=0; else pmx=X-j; x(i,j)=B*(1-cos(pi*(N-pmx)/2/N)); end end else pmz=Z-i; z(i,j)=B*(1-cos(pi*(N-pmz)/2/N)); if ( j &lt; N+1 ) pmx=j; x(i,j)=B*(1-cos(pi*(N-pmx)/2/N)); else if( j &lt;= X-N) x(i,j)=0; else pmx=X-j; x(i,j)=B*(1-cos(pi*(N-pmx)/2/N)); end end end end end end 震源位置函数及地震子波： function a=Dt(x,z,xx,zz) %x z，震源位置 %xx zz 网格大小 a=zeros(xx,zz); a(x,z)=1; end function a = ricker(t,fm) % t: 时间 % fm: 主频 % a: 幅值 a=(1-2*(pi*fm*t).^2).*exp(-(pi*fm*t).^2); end","categories":[{"name":"Geophysics","slug":"Geophysics","permalink":"/categories/Geophysics/"}],"tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"/tags/MATLAB/"}],"keywords":[{"name":"Geophysics","slug":"Geophysics","permalink":"/categories/Geophysics/"}]},{"title":"机器学习笔记（一）","slug":"2019-10-5-机器学习笔记（一）","date":"2019-10-05T13:59:00.000Z","updated":"2020-02-11T05:03:41.649Z","comments":true,"path":"2019/10/05/2019-10-5-机器学习笔记（一）/","link":"","permalink":"/2019/10/05/2019-10-5-机器学习笔记（一）/","excerpt":"","text":"第三章 线性模型1. 回归任务 主要有单元线性模型、多元线性模型和广义线性模型几种。回归任务一般根据样本的有序和无序性，采取最小二乘法求解。 一元表达式：$$\\quad f(x_i)=w^Tx_i+b$$ 多元表达式：$$f(\\hat{x}_i)=\\hat x_i^T(X^TX)^{-1}X^Ty$$ 2.分类任务 二分类和多分类任务，其中，多分类任务主要策略是拆解法，即拆分、集成。 此外还有类别不平衡问题——&gt;再缩放 第四章 决策树决策树属于分类问题","categories":[{"name":"AI","slug":"AI","permalink":"/categories/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"/tags/AI/"}],"keywords":[{"name":"AI","slug":"AI","permalink":"/categories/AI/"}]},{"title":"win 10 快捷操作","slug":"2019-10-4-win-10-快捷操作","date":"2019-10-04T14:38:10.000Z","updated":"2020-02-04T13:01:29.854Z","comments":true,"path":"2019/10/04/2019-10-4-win-10-快捷操作/","link":"","permalink":"/2019/10/04/2019-10-4-win-10-快捷操作/","excerpt":"","text":"一、WIN + R 把桌面上的一些常用软件的快捷方式复制到指定的文件夹中，可将文件夹命名为shortcut。 然后在path环境变量中写入该文件夹的路径，然后点击确定保存即可。 按下快捷键Win+r打开运行窗口，然后输入快捷方式的名称即可运行程序，例如输入chrome，回车。即可打开chrome浏览器。 常用系统指令： cmd ===&gt; cmd命令提示符write ===&gt; 写字板mspaint ===&gt; 画图notepad ===&gt; 记事本winver ===&gt; 显示windows版本devmgmt.msc ===&gt; 设备管理器dfrg.msc ===&gt; 磁盘碎片整理diskmgmt.msc ===&gt; 磁盘管理services.msc ===&gt; 本地服务设置explorer ===&gt; 资源管理器regedit ===&gt; 注册表calc ===&gt; 计算器charmap ===&gt; 字符映射表compmgmt.msc ===&gt; 计算机管理magnify ===&gt; 放大镜nslookup ===&gt; ip地址侦测器osk ===&gt; 打开屏幕键盘taskmgr ===&gt; 任务管理器 二、其他快捷键win + x win + Q 打开Cortana搜索栏 win + ← 最大化窗口到左侧的屏幕上 win + → 最大化窗口到右侧的屏幕上 win+ ↑ 最大化窗口 win+ ↓ 最小化窗口 win + Ctrl + D 新建虚拟桌面 win + Ctrl + F4 关闭虚拟桌面 win + D 显示桌面 win + E 打开文件资源管理器 win + I 打开设置 win + L 锁屏 win + S 打开搜索 小娜 Ctrl + x Ctrl+X 剪切 Ctrl + V 粘贴 Ctrl + S 保存 Ctrl + Y 恢复上一步操作 Ctrl+P 快捷打印 Ctrl + Alt + Del 任务管理器菜单 alt + x alt+空格，再按n 窗口就最小化 alt+空格，再按x 小窗口时，窗口最大化 三、win 10 手势三指操作1、三指单击触摸板，弹出小娜搜索框 2、三指同时向上划，三指同时上划，弹出多任务界面，相当于快捷：win+Tab 3、三指同时向下划，当前所有窗口最小化，显示桌面 4、三指同时向左/右划，实现快速切换任务程序，相当于快捷键：Ait+tab 四指操作1、四指单击，弹出win10操作中心，进行消息查看和开启系统功能，相当于快捷键：win+A 2、四指同时向左/右划，实现在多个桌面中，来回切换。","categories":[],"tags":[{"name":"Fun","slug":"Fun","permalink":"/tags/Fun/"}],"keywords":[]},{"title":"C++ 异常处理","slug":"C++ 异常处理","date":"2019-09-27T14:26:04.000Z","updated":"2020-02-04T13:02:02.673Z","comments":true,"path":"2019/09/27/C++ 异常处理/","link":"","permalink":"/2019/09/27/C++ 异常处理/","excerpt":"","text":"C++ 异常处理异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。 异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：try、catch、throw。 throw: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。 catch: 在您想要处理问题的地方，通过异常处理程序捕获异常。catch 关键字用于捕获异常。 try: try 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。 如果有一个块抛出一个异常，捕获异常的方法会使用 try 和 catch 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try/catch 语句的语法如下所示： try { // 保护代码 } catch( ExceptionName e1 ) { // catch 块 } catch( ExceptionName e2 ) { // catch 块 } catch( ExceptionName eN ) { // catch 块 } 如果 try 块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个 catch 语句，用于捕获不同类型的异常。 抛出异常您可以使用 throw 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。 以下是尝试除以零时抛出异常的实例： double division(int a, int b) { if( b == 0 ) { throw &quot;Division by zero condition!&quot;; } return (a/b); } 捕获异常catch 块跟在 try 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。 try { // 保护代码 }catch( ExceptionName e ) { // 处理 ExceptionName 异常的代码 } 上面的代码会捕获一个类型为 ExceptionName 的异常。如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 …，如下所示： try { // 保护代码 }catch(...) { // 能处理任何异常的代码 } 下面是一个实例，抛出一个除以零的异常，并在 catch 块中捕获该异常。 实例#include &lt;iostream&gt; using namespace std; double division(int a, int b) { if( b == 0 ) { throw &quot;Division by zero condition!&quot;; } return (a/b); } int main () { int x = 50; int y = 0; double z = 0; try { z = division(x, y); cout &lt;&lt; z &lt;&lt; endl; } catch (const char* msg) { cerr &lt;&lt; msg &lt;&lt; endl; } return 0; } 由于我们抛出了一个类型为 const char* 的异常，因此，当捕获该异常时，我们必须在 catch 块中使用 const char*。当上面的代码被编译和执行时，它会产生下列结果： Division by zero condition! C++ 标准的异常C++ 提供了一系列标准的异常，定义在 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示： 下表是对上面层次结构中出现的每个异常的说明： 异常 描述 std::exception 该异常是所有标准 C++ 异常的父类。 std::bad_alloc 该异常可以通过 new 抛出。 std::bad_cast 该异常可以通过 dynamic_cast 抛出。 std::bad_exception 这在处理 C++ 程序中无法预期的异常时非常有用。 std::bad_typeid 该异常可以通过 typeid 抛出。 std::logic_error 理论上可以通过读取代码来检测到的异常。 std::domain_error 当使用了一个无效的数学域时，会抛出该异常。 std::invalid_argument 当使用了无效的参数时，会抛出该异常。 std::length_error 当创建了太长的 std::string 时，会抛出该异常。 std::out_of_range 该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator。 std::runtime_error 理论上不可以通过读取代码来检测到的异常。 std::overflow_error 当发生数学上溢时，会抛出该异常。 std::range_error 当尝试存储超出范围的值时，会抛出该异常。 std::underflow_error 当发生数学下溢时，会抛出该异常。 定义新的异常您可以通过继承和重载 exception 类来定义新的异常。下面的实例演示了如何使用 std::exception 类来实现自己的异常： 实例#include &lt;iostream&gt; #include &lt;exception&gt; using namespace std; struct MyException : public exception { const char * what () const throw () { return &quot;C++ Exception&quot;; } }; int main() { try { throw MyException(); } catch(MyException&amp; e) { std::cout &lt;&lt; &quot;MyException caught&quot; &lt;&lt; std::endl; std::cout &lt;&lt; e.what() &lt;&lt; std::endl; } catch(std::exception&amp; e) { //其他的错误 } } 这将产生以下结果： MyException caught C++ Exception 在这里，what() 是异常类提供的一个公共方法，它已被所有子异常类重载。这将返回异常产生的原因。","categories":[{"name":"Coding","slug":"Coding","permalink":"/categories/Coding/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"/tags/c-c/"}],"keywords":[{"name":"Coding","slug":"Coding","permalink":"/categories/Coding/"}]},{"title":"8-queen","slug":"8queen","date":"2019-09-25T14:06:41.000Z","updated":"2020-02-11T05:03:02.500Z","comments":true,"path":"2019/09/25/8queen/","link":"","permalink":"/2019/09/25/8queen/","excerpt":"","text":"八皇后问题​ 本文参考《算法竞赛经典入门》一书191页完成。 由国际象棋棋盘为 $8\\times 8$的网格，皇后所在行、列、主对角线和副对角线都是其攻击范围，八皇后问题即求解八个皇后不互相攻击的方法。 我们可以通过枚举每个位置暴力求解，但是这样计算量过大往往很难实现；可以通过题目的相关限制来简化枚举过程，此处我们用到了回溯法。 核心代码： void queen(int n,int cur,int s[] ) { //n，棋盘边长；cur，当前行；s临时位置变量 if (n == cur) { count++; for(int j=0;j&lt;8;j++) //存放每一种解 C[count][j]=s[j]; } else { for (int i= 0;i&lt;n;i++) { if( !b[0][i] &amp;&amp; !b[1][cur+i] &amp;&amp; !b[2][i-cur + n] ) { s[cur]=i; b[0][i]=b[1][cur+i]=b[2][i-cur + n]=1; queen(n,cur+1,s); b[1][cur+i]=b[2][i-cur + n]=b[0][i]=0; } } } } 国际象棋中每个皇后的可移动轨迹如下图所示： 从图中我们很容易得知，每行最多放一个皇后；由于每列最多也只能放一个皇后，我们将已经安置好的皇后所在的列号存入数组 $b[0][i]$ 之中,数组为0时表示可以放置，当数组值为1时表示不能放置；对于主对角线和副对角线，在棋盘中，行号和列号满足直线方程 :$$y = x+b$$ $$y=-x+b’$$ 经过简单的移项，我们就可以得到对应的同一主对角线和副对角线所具有的位置关系：$$b=y-x$$ $$b’=y+x$$ 每条线上的$b、 b’$为常数，分别其存入$b[1][b] 和 b[2][b’] $之中。 每层处理方法均相同，且遇到死胡同时需要返回上级选择新路线，采用递归的写法。 递归边界分为两种，一是中途遇到其他皇后，提前退出递归，并将各个参数恢复至进入递归之前的状态，返回上一层递归；二是当最后一层也满足条件时说明找到了一组可行解，此时记录下该可行解。需要说明的是，若中途不作记录，程序结束时临时储存的数组的值不满足八皇后问题，因为当最后一组可行解记录过后，遇到无法进行到最终的分支时，临时存储的数组其值发生了改变，且最终未恢复至正确解的值，产生错误。 完整代码如下： #include&lt;stdio.h&gt; #include&lt;string.h&gt; void print_board(char a[][8]) { //打印棋盘 for (int i=0;i&lt;8;i++) { for (int j=0;j&lt;8;j++) { printf(&quot;%c &quot;,a[i][j]); } printf(&quot;\\n&quot;); } } int count = 0; int b[3][16]={0}; //分别表示同列、同主对角线、副对角线 int C[100][8]; //保存全部可能解 void queen(int n,int cur,int s[] ) { //n，棋盘边长；cur，当前行；s临时位置变量 if (n == cur) { count++; for(int j=0;j&lt;8;j++) //存放每一种解 C[count][j]=s[j]; } else { for (int i= 0;i&lt;n;i++) { if( !b[0][i] &amp;&amp; !b[1][cur+i] &amp;&amp; !b[2][i-cur + n] ) { s[cur]=i; b[0][i]=b[1][cur+i]=b[2][i-cur + n]=1; queen(n,cur+1,s); b[1][cur+i]=b[2][i-cur + n]=b[0][i]=0; } } } } int main () { //建立棋盘 char a[8][8]; for (int i =0;i&lt;8;i++) for (int j=0;j&lt;8;j++) a[i][j]=&#39;Q&#39;; int s[8]; //临时存储变量 memset(s,-1,sizeof(s)); queen(8,0,s); printf(&quot;The solution have %d successfull method(s).\\n&quot;,count); char control; do{ printf(&quot;Please enter the solution number(1~92) to view: \\n&quot;); int num; scanf(&quot;%d&quot;,&amp;num); printf(&quot;The %d solution is : \\n&quot;,num); for(int i = 0;i&lt;8;i++) { a[i][C[num][i]]=&#39;*&#39;; } print_board(a); printf(&quot;Enter n/N to exit or y/Y to continue:\\n&quot;); getchar(); scanf(&quot;%c&quot;,&amp;control); }while(control==&#39;y&#39;|| control == &#39;Y&#39;); return 0; } ​","categories":[{"name":"Coding","slug":"Coding","permalink":"/categories/Coding/"}],"tags":[{"name":"C","slug":"C","permalink":"/tags/C/"}],"keywords":[{"name":"Coding","slug":"Coding","permalink":"/categories/Coding/"}]}]}